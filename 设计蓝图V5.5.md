# ESP32S3 - 设计蓝图
本文档是模块化管理系统项目的核心设计指南

## 硬件资源规划 (Hardware Resource Planning)
ESP32S3R8N8 - https://wiki.lckfb.com/zh-hans/esp32s3r8n8/

### 双核CPU (Xtensa双核240MHz)

#### 核心分配策略：

##### Core 0 (Pro CPU) - 数据密集型核心
专用于处理需要持续、高强度计算的任务，与网络和应用逻辑完全隔离，以保证其性能不受影响。

###### 主要任务： USB摄像头数据流处理、MJPEG解码、条码识别算法。

##### Core 1 (App CPU) - 应用与网络核心
负责运行所有应用逻辑、网络服务和UI交互。

###### 主要任务：Web服务器、WebSocket通信、WiFi管理、蓝牙服务、FreeRTOS任务调度、UI命令处理。

#### 实现规范：

##### 所有FreeRTOS任务在创建时，必须使用 `xTaskCreatePinnedToCore` 明确指定其运行的核心，严禁在未指定核心的情况下创建任务。

### 内存系统 (Memory System)

#### 8MB PSRAM
(大块、非频繁访问的数据存储区)

##### 应用场景：

###### 摄像头帧缓冲 (Frame Buffer)：
存储从UVC摄像头获取的完整视频帧。

###### 文件上传缓冲区：
作为Web文件上传功能的大容量暂存区。

###### 大型数据结构：存储如i18n国际化加载的完整JSON文件等。

##### 内存管理方案：
FreeRTOS的堆管理机制 (Heap 5) 是使用PSRAM的必要条件。

###### 实现一个 Sys_MemoryManager，提供多池内存管理器用于内存分配和跟踪。根据预期的需求，初始化多个不同尺寸的内存池，从根本上避免内存碎片化、提高PSRAM利用率。还可以集成SRAM的监控；可以在系统监视任务中定期打印SRAM的堆信息，及早发现碎片问题。

###### 实施细节：

   * 自动分配，使用SP-IDF v5.x本身提供强大的多堆（Multi-heap）功能；使用 heap_caps_add_region函数。
heap_caps_get_info(MALLOC_CAP_FRAMEBUFFER, &info) 来获取这个专属堆的详细信息（总大小、已用空间、剩余空间、最大可用块等）。

   * 结合手动分配，在 `Sys_MemoryManager::initializePools()` 中，一次性从PSRAM中 `heap_caps_malloc` 为特定的大块内存（如摄像头帧缓冲）创建一个专用的堆 heap_caps_add_region，实现内存隔离。

      * 管理器内部维护一个状态数组（如 `bool block_is_used[blockCount]`）来跟踪每个内存块的可用性。

      * 提供专用的接口，如 `void* get_frame_buffer()` 和 `void release_frame_buffer(void* buffer)`。这些接口通过查找状态数组来分配和回收内存块，而不是进行实时的 `malloc` 和 `free`。

#### 512KB SRAM
(高速、频繁访问的数据和任务堆栈)

##### 应用场景：
1、所有FreeRTOS任务的堆栈。
2、高频读写的全局变量和静态变量。
3、性能敏感算法（如识别算法）所需的小块、临时数据。

##### 内存管理方案：
依赖FreeRTOS的堆管理机制 (Heap 5)。

### 闪存系统 (Flash System)

#### 8MB Quad Flash

#### **自定义分区表 (`my_8MB.csv`)**:

##### `nvs` (20k): 存储设备配置，如WiFi凭据、蓝牙名称、系统设置等。

##### `otadata` (8k): OTA升级管理。

##### `app0` / `app1` (各2.5M): 存储两份固件，用于OTA。

##### `littlefs` (932k): 在代码中应视为 **LittleFS** 分区。专用于存储Web UI相关的静态资源（HTML, JS, CSS, Gzip压缩文件）。

##### `ffat` (1984k): **FAT分区**。专用于存储用户上传的大文件（如WAV, JSON, 固件包等）。

##### `coredump` (64k): 系统崩溃时的核心转储。

#### 文件系统LittleFS、FATFS：
在根项目结构为文件系统镜像建立独立的源文件夹：
data<-- 默认的data目录，用于默认的LittleFS/SPIFFS
media<-- 新增的media目录，用于 fatfs 的FAT分区
注意！esp-IDF固定先从ffat分区写入！分区顺序要先 fatfs再到SPIFFS 的SubType。

##### 文件挂载：
`Sys_Filesystem` 模块负责统一挂载 LittleFS 和 FFat。

##### 初始化：
采用 “失败时格式化” (Format on Fail) 的策略。即 `LittleFS.begin(false)`，只在挂载失败时才进行格式化，避免每次启动都擦除用户数据。

##### web路由映射：
FFat 挂载：_server->serveStatic("/media", FFat, "/");
LittleFS 挂载：_server->serveStatic("/", LittleFS, "/"); // 在 LittleFS 根目录查找文件

##### Web上传功能：
实现并允许用户通过浏览器将WAV/JSON文件上传到FATFS分区。

### 板载硬件

#### 可编程LED（GPIO 48）

#### BOOT按钮（GPIO 0）
用于长按实现恢复出厂设置（复用"恢复出厂"）按钮功能

#### 后期扩展：- I2S功放喇叭
考虑硬件接线

#### 后期扩展：- 16GB TF卡
考虑文件系统的初始化、读写操作

### USB扩展硬件

#### USB类型4K-USB摄像头
(MJPG/YUY2格式10FPS)

#### USB类型1080P-USB摄像头
(MJPG格式30FPS)

## 服务层设计 (Service Layer Design)
服务层是建立在硬件和核心模块之上的应用逻辑核心，以FreeRTOS为基础，确保系统的稳定性和响应性。

### FreeRTOS 任务模型（服务器推送通道）
(队列 (Queues)数据流：源任务 -> 数据队列 -> Pusher任务 -> WebSocket)

#### 设计原则：严格遵循“异步非阻塞”原则，将不同职责的任务分离，并使用队列进行任务间通信。

#### 核心任务定义：

##### `Task_Worker` (Core 1, 优先级 1)：命令处理器。
系统的“主力”，唯一一个被允许执行潜在耗时操作的任务。它阻塞等待`xCommandQueue`中的命令，执行后将结果通过WebSocket广播。

##### `Task_SystemMonitor` (Core 1, 优先级 1)：周期性监视器。
以固定的频率（例如1000ms）运行，负责执行周期性检查和维护任务。

###### 调用`Sys_WiFiManager::update()`来处理非阻塞的WiFi重连逻辑。

###### 检查 _is_dirty 标记，为 true 则调用 Sys_SettingsManager::commit()，将内存中完整的配置一次性写入NVS，然后清除“脏”标记。

###### 监控全局状态，并喂养空闲任务看门狗TWDT

##### `Task_WebSocketPusher` (Core 1, 优先级 2)：数据推送器。
FreeRTOS 等待事件组逻辑，专职的数据出口，它阻塞等待任何一个事件位的发生。比如等待来自多个源头的数据队列（如`xStateQueue`, `xBarcodeQueue`），并将数据通过WebSocket发送到前端。职责单一。

###### 多事件触发单任务，FreeRTOS  事件组 (Event Groups)Task_WebSocketPusher，可以等待一个事件组，其中包含“新条码数据就绪”、“系统状态更新”、“日志消息可用”等事件；它可以在任何一个事件发生时被唤醒，而不是轮询多个队列。

##### `Task_ImageProcessor` (Core 0, 优先级 2)：(未来规划)图像处理器。
CPU密集型任务，与Core 1完全隔离，通过`xBarcodeQueue`队列向外输出结果。

##### 其它待更新

#### 通信机制：

##### 命令队列 (`xCommandQueue`)：
用于从Web服务器接收前端命令，是`taskWorker`的唯一输入源。

######  定义一个通用的命令结构体 Command_t，它包含一个命令类型枚举 CommandType 和一个 union 或 void* 指针来携带不同命令的参数。这样队列中传递的元素大小就是固定的。

##### 状态/数据队列 (`xStateQueue`, `xBarcodeQueue`)：
用于从数据源任务向`taskWebSocketPusher`传递需要实时显示的数据。

##### 任务通知 (Task_Notifications)：
对于不需要传递大量数据的简单任务间同步，应优先考虑使用更轻量的任务通知。

### HTTP RESTful API（客户端请求通道）

#### 对于“请求-响应”模式的操作使用 fetch API 调用HTTP端点处理（例如 get_settings, save_settings, scan_wifi等）。

### 日志系统 (Logging System)

#### 实现方式：

##### 日志重定向：
后端通过重写`esp_log_set_vprintf`或使用自定义的`ESP_LOG_`宏，将日志（特别是`INFO`, `WARN`, `ERROR`级别）格式化为JSON字符串。

##### 实时推送：
格式化后的日志消息被发送到`xStateQueue`（或一个专用的日志队列），由`taskWebSocketPusher`通过WebSocket推送到前端。

#### 前端实现：

##### 前端接收到`log`类型的WebSocket消息后，根据日志级别（`level`字段）添加不同的CSS class（如`text-info`, `text-warning`, `text-danger`），并在日志控制台中显示带时间戳和级别的格式化日志。

### 系统监控与看门狗 (System Monitoring & Watchdog)

#### 启用ESP-IDF内建的TWDT对特定的、关键的FreeRTOS任务进行监控。

#### 将Task_Worker和Task_ImageProcessor等可能因外部库或循环逻辑而卡死的关键任务，注册到TWDT。在其主循环的关键路径执行完毕后、下一次循环开始前，必须有明确的 esp_task_wdt_reset() 调用喂狗表明其仍正常运行。

### 闪存友好日志系统

#### 闪存滤波优化

### 功耗管理策略 (Power Management Strategy)

#### 为延长设备在电池供电下的续航时间或降低待机能耗，动态调整系统行为以达到节能目的的系统级服务逻辑策略。

#### 设计原则：
只有在需要时才激活高功耗的组件（如WiFi/蓝牙射频、高速CPU）。
抓住一切可能的空闲窗口，让系统进入合适的低功耗状态。

#### 实现方式：

##### 动态调频：
没有CPU密集型任务（如图像处理、大量数据加解密）运行时，Task_SystemMonitor可以调用esp_pm_configure()将CPU频率从240MHz动态降低到80MHz或更低。
当Task_Worker接收到需要高性能的命令时，可以临时请求将CPU频率调回240MHz，任务完成后再降回去。

##### 睡眠模式：
 由Task_SystemMonitor判断。当WiFi和蓝牙均未连接、没有活动的USB连接、所有应用任务队列为空时，满足所有条件超过一定时间（如30秒）后调用esp_light_sleep_start()触发睡眠。
配置GPIO唤醒、定时器唤醒、USB事件唤醒等一个或多个源作为唤醒触发器。

##### 外设时钟门控：
在sdkconfig中启用CONFIG_PM_ENABLE。
对于非核心且不常用外设（如I2S、LEDC、特定Timer等），确保在不使用时，其驱动程序被正确地deinit，以便电源管理系统可以自动关闭它们的时钟。

#### 模块协调

##### Sys_WiFiManager 和 Sys_BlueToothManager 等需要提供清晰的isConnected()状态接口。

##### Task_SystemMonitor 是功耗策略的主要决策者和执行者。

## 代码规范 (Code Specifications)

### 命名规范：

#### **类名**: 采用帕斯卡命名法（PascalCase），并使用项目/模块前缀，例如 `Sys_WiFiManager`。

#### **函数/方法名**: 采用驼峰命名法（camelCase），如 `saveWiFiSettings`。

#### **私有成员变量**: 以下划线 `_` 开头，如 `_instance`。

#### 关键核心：帕斯卡命名法并加入下划线 `_`。例如`Task_Worker`。

### 代码注释：
所有代码中比如函数、类和复杂的逻辑块都必须有详细友好统一的、专业的，可读性和可接近性的中文注释；参考'核心模块接口定义'章节中Sys_SettingsManager.h & .cpp的专业注释风格。

### 错误处理：

#### 所有与系统资源交互的操作（如队列发送/接收、内存分配、文件I/O）**必须**检查其返回值。

#### 对可能的错误情况（如队列已满、内存不足）必须有明确的处理逻辑（如打印错误日志、向前端返回错误提示）。

### 安全性：

#### 输入验证：
所有从前端接收的数据（特别是`save_*`命令的payload），在后端**必须**进行有效性验证和清理，防止注入或格式错误导致系统崩溃。

#### Web认证(后期实现)：
为Web服务器添加基于表单的登录认证机制。密码以哈希值形式存储在NVS中。

##### 创建 `login.html` 登录页面，在 `Sys_WebServer` 中增加会话验证逻辑，未认证的访问将重定向到登录页。

##### 在 `Sys_NvsManager` 中增加 `savePasswordHash()` 和 `verifyPassword()` 函数，用于密码的存储和验证。

##### 登录成功后，服务器生成会话令牌，客户端在后续的请求中（HTTP或WebSocket）需携带此令牌进行验证。

### 多任务与线程安全：
必须引入同步机制。为每个MemoryPool或为整个管理器创建一个FreeRTOS互斥信号量 (Mutex)。在进入分配/释放的临界区代码前获取锁，退出时释放锁。

#### 设计原则：
在多任务环境下，任何可能被多个任务同时访问的共享资源（如全局变量、单例对象的成员、文件系统、外设等），其访问代码 **必须** 通过同步机制进行保护，以防止竞态条件 (Race Condition) 导致的数据损坏或系统崩溃。

#### 实现规范：
本项目使用一个基于RAII (Resource Acquisition Is Initialization) 模式的锁守护者类 Sys_LockGuard。

##### RAII模式: Sys_LockGuard对象在栈上创建时，其构造函数会自动获取（Take）一个互斥锁；当函数退出时（无论是正常返回还是因异常退出），该对象的析构函数会被自动调用，从而保证互斥锁一定会被释放。从根本上消除了因忘记调用 xSemaphoreGive() 而导致的死锁风险。

##### 识别与保护临界区：
识别代码中的“临界区”（即访问共享资源的代码片段），并使用Sys_LockGuard进行保护。

##### 本项目中实现线程安全保护的关键模块：

###### Sys_MemoryManager：
共享资源: 内存池的状态标志位向量 (used_flags)。
临界区: getMemoryBlockFromPool() 和 releaseMemoryBlock() 中对used_flags的读写操作。
保护措施: 使用一个内部的互斥锁 _mutex 和 Sys_LockGuard 来保护这些方法。

###### Sys_SettingsManager：
共享资源: 内部的配置缓存结构体 (_settings) 和“脏”标记 (_is_dirty)。
临界区: 所有公共的getter和setter方法，以及commit(), factoryReset()等。
保护措施: 使用一个内部的互斥锁 _mutex 和 Sys_LockGuard 来保护所有对共享成员的访问。

###### Sys_FlashLogger：
共享资源: 底层的日志文件 (File对象)。
临界区: writeBufferToFile() 和 clearLogFile() 中对日志文件的打开、写入、删除等I/O操作。
保护措施: 使用一个内部的文件操作互斥锁 _file_mutex 和 Sys_LockGuard 来确保同一时间只有一个任务能操作日志文件。

#### 以下模块由于其单例特性和多任务调用场景，必须 实现线程安全保护。

##### Sys_MemoryManager: 在分配和释放内存池块时，对 used_flags 向量的修改。

##### Sys_FlashLogger: 在将缓冲区写入文件时，对 File 对象的操作。

##### Sys_SettingsManager: “脏”标记在复杂场景下对 _is_dirty 的访问也应受保护。

### 调试模式与日志宏：

#### 实现可配置的调试模式，在不修改核心业务逻辑代码的情况下，控制详细调试信息的输出。

##### 调试模式开关：
在 `platformio.ini` 文件中，通过 `build_flags` 定义一个全局宏，如 `-DCORE_DEBUG_MODE=1`。这允许在编译固件时就决定是否启用调试模式。发布版本可以设置为 `-DCORE_DEBUG_MODE=0`，以完全移除调试代码，减小固件体积。

##### 运行时开关：
在 `Sys_SettingsManager` 中增加一个 `bool isDebugModeEnabled` 配置项，存储在NVS中。用户可以通过Web界面的一个隐藏开关或特定命令来动态开启或关闭调试模式，无需重新编译固件。

### 配置版本与数据迁移：

#### 在NVS配置里添加版本号，读取数据时版本号匹配才正常加载配置，不匹配就执行迁移逻辑

## 开发环境与工具链 (Development Environment & Toolchain)

### PlatformIO 配置（platformio.ini）

#### 平台：espressif32@~6.11.0 对应 ESP-IDF v5.4.1

#### 框架：Arduino Core v2.0+

#### 核心配置：

##### `board_build.arduino.memory_type = qio_opi`: **必须**使用此配置，以同时启用QIO Flash和OPI Octal PSRAM的最高性能模式。

##### `board_build.partitions = my_8MB.csv`: 指定使用自定义分区表。

##### `board_build.filesystem = littlefs`: 指定默认文件系统为LittleFS，用于存放Web UI资源。

#### 编译标志：

##### build_flags =
  -DCONFIG_SPIRAM_USE_MALLOC
;启用 PSRAM 内存分配器
  -DCONFIG_SPIRAM_MALLOC_USE_MALLOC
;使默认的 malloc() 函数使用 PSRAM

#### 上传与监视端口：

##### 上传配置：
upload_port       = COM3               
; 指定上传固件的端口 (CH340K硬件UART桥接芯片)
upload_speed      = 921600             
; 设置上传波特率，提高烧录速度

##### 串口配置（根据硬件）：
monitor_port      = COM4               
; 指定监视输出的端口 (N8R8程序输出通过硬件UART0，经由CH340K芯片，最终出现在COM4上)
monitor_speed     = 115200             
; 设置监视器波特率。

### 前端技术栈与构建流水线

#### 框架：Bootstrap 5 + Vanilla JavaScript

#### 数据交互：

##### 实时数据：使用 WebSocket 进行双向通信。

##### 按需请求数据： 对于非实时数据（如初次加载配置），通过WebSocket发送JSON命令来主动请求。

#### UI更新机制：

##### 状态驱动：前端JS维护一个全局`state`对象。当WebSocket收到数据时，更新`state`对象，然后调用渲染函数（如`renderDashboard(state)`)来更新UI。

##### 高效DOM操作：使用JS的模板字符串（template literals）来动态生成HTML片段，并通过 `element.innerHTML` 进行一次性更新，避免频繁操作单个DOM元素。

##### 事件委托：将事件监听器绑定在不会被重绘的父容器上，利用事件冒泡来处理子元素的事件，以避免在`innerHTML`更新后事件丢失。

#### UI渲染模式推荐

##### 使用JS的模板字符串（template literals）来动态生成HTML片段，并用 element.innerHTML 更新DOM（将事件监听器绑定在不会被重绘的父容器上，而不是绑定在会被替换掉的子元素上），这比操作单个DOM元素性能更好。
实现参考：在JS中维护一个全局state对象，当WebSocket收到数据，更新state对象，调用一个render()函数更新组件（例如一个卡片）。

###### // 代码参考示例：
const cardContainer = document.getElementById('card-container');
cardContainer.innerHTML = '<div class="card-content">...<button data-action="restart">重启</button>...</div>';
// 在初始化时，只绑定一次事件到父容器
cardContainer.addEventListener('click', (event) => {
  if (event.target.dataset.action === 'restart') {
    // 执行重启逻辑
  }
});

#### 前端资源优化：

##### 实现方式：通过 `extra_scripts = pre:minify_gzip.py` 在编译时自动执行。

##### 流程：`minify_gzip.py` 脚本在构建文件系统镜像前，自动对 `/data` 目录下的 `.js` 和 `.css` 文件进行 Minify (移除空格和注释) 与 Gzip压缩。

##### 服务器支持：`Sys_WebServer` 实现Gzip内容协商逻辑，当请求的资源存在 `.gz` 版本时，优先发送压缩文件并附带 `Content-Encoding: gzip` 响应头。

### 后端通信

#### Web服务器：Sys_WebServer

##### 依赖库：
AsyncTCP-esphome  @ ^2.1.4
//异步TCP库 (ESPAsyncWebServer的依赖) 
ESPAsyncWebServer-esphome @ ^3.4.0`
//请注意这个库的调用类名是：AsyncWebServer

#### WebSocket：服务器主动通信，由`ESPAsyncWebServer-esphome` 内建

##### 心跳机制：
WebSocket连接实现Ping/Pong心跳机制，确保连接活跃，用于检测连接是否断开。

#### JSON处理：
(轻量级数据交换)

##### 依赖库：
bblanchon/ArduinoJson @ ^7.4.1

##### 错误处理：所有JSON响应中**必须**包含统一的成功/失败状态码和可选的错误消息，方便前端进行统一处理和国际化。

##### Web API构建：
JSON RPC 2.0（远程过程调用），让前后端逻辑更清晰，通信更规范。

###### 创建API_SPEC.md，作为前后端通信契约，所有通信均基于JSON RPC 2.0规范，通过WebSocket传输。
# API Specification (JSON RPC 2.0)

本文件定义了ESP32管理系统的前后端通信契约。所有通信均基于JSON RPC 2.0规范，通过WebSocket传输。

## 基本原则

- **请求 (Request)**: 客户端向服务器发送包含 `jsonrpc`, `method`, `params`, `id` 的请求对象。
- **响应 (Response)**: 服务器返回包含 `jsonrpc`, `result` 或 `error`, `id` 的响应对象。
- **通知 (Notification)**: 服务器主动向客户端推送不带 `id` 的消息，用于状态更新和日志。

---

## 1. 系统命令 (System Commands)

### Method: `system.reboot`
- **Description**: 请求系统重启。
- **Params**: `null`
- **Result**: `{"status": "rebooting"}`
- **Example**:
  - **Request**: `{"jsonrpc": "2.0", "method": "system.reboot", "id": 1}`
  - **Response**: `{"jsonrpc": "2.0", "result": {"status": "rebooting"}, "id": 1}`

### Method: `system.factoryReset`
- **Description**: 执行恢复出厂设置，将擦除所有用户配置。
- **Params**: `null`
- **Result**: `{"status": "resetting"}`

---

## 2. 设置管理 (Settings Management)

### Method: `settings.get`
- **Description**: 获取当前所有系统设置。
- **Params**: `null`
- **Result**: `Object` - 包含所有设置项的JSON对象。
- **Example**:
  - **Response**: `{"jsonrpc": "2.0", "result": {"wifi": {"ssid": "MyNet"}, "bluetooth": {"deviceName": "ESP32-Sys"}}, "id": 2}`

### Method: `settings.saveWiFi`
- **Description**: 保存新的WiFi凭据。
- **Params**:
  - `ssid` (string, required): WiFi的SSID。
  - `password` (string, optional): WiFi的密码。
- **Result**: `{"status": "success"}`

### Method: `settings.saveBluetooth`
- **Description**: 保存新的蓝牙设备名称。
- **Params**:
  - `deviceName` (string, required): 新的蓝牙广播名称。
- **Result**: `{"status": "success"}`

---

## 3. WiFi管理 (WiFi Management)

### Method: `wifi.scan`
- **Description**: 请求进行一次WiFi扫描。结果将通过`wifi.scanResult`通知异步推送。
- **Params**: `null`
- **Result**: `{"status": "scanning"}`

---

## 4. 服务器推送通知 (Server Notifications)

### Method: `log.message`
- **Description**: 服务器推送的日志消息。
- **Params**:
  - `level` (string): "INFO", "WARN", "ERROR"
  - `message` (string): 日志内容。
  - `timestamp` (number): 时间戳。

### Method: `system.stateUpdate`
- **Description**: 服务器推送的系统状态更新。
- **Params**: `Object` - 包含变化的状态键值对，例如 `{"heap_free": 123456, "uptime": 7200}`。

### Method: `wifi.scanResult`
- **Description**: 推送WiFi扫描结果。
- **Params**: `Array` - 扫描到的WiFi网络对象数组 `[{"ssid": "Net1", "rssi": -50}, ...]`。

## UI/UX 设计总则 (UI/UX Design Principles)

### 设计风格：整体采用Bootstrap 5风格，保持色彩、字体、卡片和按钮样式的一致性。

### 响应式布局：

#### 桌面端 (≥ Medium Screens)：
采用经典的“左侧垂直导航 + 中部内容区”布局。当内容需要再次分组时，在内容区顶部使用水平Tabs。

#### 移动端 (Small Screens)：

##### 左侧导航栏隐藏，通过顶部的汉堡按钮以**Offcanvas**形式滑出。

##### 内容区内的水平Tabs应转换为**手风琴 (Accordion)**布局，以优化垂直空间。

##### 底部标签栏（仅移动端可见），根据对应核心功能创建4个常用标签（nav组件+fixed-bottom）

### 交互反馈：

#### 精确请求与响应：

##### 危险操作 (如重启)：
必须使用Bootstrap的**模态框 (Modal)**进行二次确认。

##### 常规操作 (如保存配置)：后端处理完成后，必须返回一个确认消息，前端以非阻塞的**浮动提示 (Toast)**形式显示结果。

#### 加载指示器：
在进行网络请求或耗时操作时（如WiFi扫描），UI上必须有明确的加载指示器（如按钮临时禁用、显示Spinner），避免用户认为应用卡死。

#### 占位符交互：
全部输入框内可显示对应已保存的值，空值未设置则有占位符文本用于提示需要输入的内容。

### 状态同步：

#### 当任何配置被成功修改后，后端必须向所有已连接的客户端广播一份最新的、完整的相关配置JSON。这确保了即使用户打开多个页面，看到的数据也永远是一致的。

### 连接状态的视觉化：

#### 建立全局可视化的连接状态指示器

#### 必须监听WebSocket的 onopen, onclose, onerror 等事件。

#### 连接断开时页面顶部弹出一个不可关闭的固定警告框 (Fixed Alert)；所有需要与后端交互的按钮被禁用并灰显。

#### 前端必须实现指数退避 (Exponential Backoff) 重连逻辑策略。

### 服务辅助 (PWA)

#### 离线访问：
实现离线访问或更快的加载速度，可以考虑将前端升级为渐进式Web应用（PWA），使用Service Worker进行资源缓存。

#### 安装到主屏幕：
PWA可以被添加到手机主屏幕，像原生App一样启动，提供沉浸式体验。

## 核心模块接口定义 (Core Module Interfaces)
(模块化设计、单例模式封装class)

### Sys_SettingsManager.h & .cpp 
//本模块是系统的“中央登记处”，负责管理所有可配置项。

#### 配置缓存: 所有配置都缓存在内存的struct中，实现零延迟读取。

“脏”标记 (Dirty Flag): 避免不必要的NVS写入，延长Flash寿命。

底层分离: 完全依赖Sys_NvsManager作为其唯一的存储后端。

版本控制与迁移: 内置版本检查机制，为未来的固件升级提供健壮性。

单例模式: 提供全局唯一的访问点，作为系统配置的“唯一事实来源”。

##### /**
 * @file Sys_SettingsManager.h
 * @brief 系统设置管理器的接口定义
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 *
 * @details
 * 该模块是系统配置的“唯一事实来源 (Single Source of Truth)”。
 * 它采用内存缓存和“脏标记”机制，实现了配置的快速读取和对Flash寿命友好的延迟写入。
 * 所有其他模块需要获取配置时，都应通过此管理器进行，以确保数据的一致性。
 *
 * @note  本模块的所有公共方法均为线程安全，内部通过互斥锁实现同步。
 */
#pragma once

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "Sys_LockGuard.h" // 引入RAII锁

/**
 * @struct SystemSettings
 * @brief 一个集中包含了所有系统可配置项的结构体。
 *
 * @details
 * 将所有配置项聚合在一个结构体中，便于作为一个整体从NVS中加载和保存(BLOB操作)。
 * 成员的默认值在此处通过C++11的成员初始化器定义，用于`loadDefaults()`。
 */
struct SystemSettings {
    // --- 版本控制 ---
    /** @brief 配置结构体的版本号，用于固件升级时的数据迁移。*/
    uint32_t settings_version = 1;

    // --- WiFi 设置 ---
    /** @brief Station模式下连接的WiFi SSID。*/
    char wifi_ssid[33] = "esp32s3";
    /** @brief Station模式下连接的WiFi 密码。*/
    char wifi_password[65] = "12345678";
    /** @brief WiFi工作模式的枚举。*/
    enum WiFiMode { WIFI_MODE_NULL = 0, WIFI_MODE_STA = 1, WIFI_MODE_AP = 2, WIFI_MODE_AP_STA = 3 };
    /** @brief 当前的WiFi工作模式。*/
    WiFiMode wifi_mode = WIFI_MODE_AP_STA;
    /** @brief 是否启用静态IP。*/
    bool wifi_static_ip_enabled = false;
    /** @brief 静态IP地址。*/
    char wifi_static_ip[16] = "";
    /** @brief 子网掩码。*/
    char wifi_subnet[16] = "";
    /** @brief 网关地址。*/
    char wifi_gateway[16] = "";

    // --- 蓝牙设置 ---
    /** @brief 是否启用蓝牙功能。*/
    bool bluetooth_enabled = true;
    /** @brief 蓝牙广播的设备名称。*/
    char bluetooth_name[33] = "ESP32S3-Device";

    // --- 调试设置 ---
    /** @brief 运行时的调试日志开关。*/
    bool debug_mode_enabled = true;
};


/**
 * @class Sys_SettingsManager
 * @brief 系统设置管理器，实现了配置的缓存、持久化、版本控制和线程安全访问。
 */
class Sys_SettingsManager {
public:
    /**
     * @brief 获取Settings管理器的单例实例。
     * @note  为保证线程安全，此方法应在系统进入多任务调度前（如在setup()中）完成首次调用。
     * @return Sys_SettingsManager* 指向唯一实例的指针。
     */
    static Sys_SettingsManager* getInstance();
    
    // 删除拷贝构造函数和赋值操作符，确保单例模式。
    Sys_SettingsManager(const Sys_SettingsManager&) = delete;
    Sys_SettingsManager& operator=(const Sys_SettingsManager&) = delete;

    /**
     * @brief 在系统启动时调用，从NVS加载配置或初始化为默认值。
     * @note 必须在`Sys_NvsManager::initialize()`之后调用。
     */
    void begin();

    /**
     * @brief 获取当前内存中所有配置的一份线程安全快照。
     * @details 此方法返回一个配置的**副本**，适用于需要同时访问多个配置项，
     *          并需要保证这些配置项在操作期间一致的场景。
     * @return SystemSettings 配置结构体的副本。
     */
    SystemSettings getSettings();

    // --- 线程安全的单个配置项 Getter ---
    // 为频繁访问的单个配置项提供高效、线程安全的只读方法，避免不必要的结构体拷贝。
    
    /** @brief 线程安全地获取运行时调试模式状态。*/
    bool isDebugModeEnabled();
    /** @brief 线程安全地获取WiFi模式。*/
    SystemSettings::WiFiMode getWiFiMode();
    /** @brief 线程安全地获取蓝牙设备名称。*/
    String getBluetoothName();
    // ... 未来可为其他需要单独访问的配置项添加getter ...
    
    // --- 修改与持久化 ---

    /**
     * @brief 将内存中的修改提交到NVS。
     * @details 只有当`isDirty()`返回`true`时，才会执行实际的写入操作。
     *          这个函数被`Task_SystemMonitor`周期性调用，实现了延迟写入。
     * @return bool `true` 如果提交成功或无需提交，`false` 如果写入NVS失败。
     */
    bool commit();
    
    /**
     * @brief 强制将当前内存中的配置立即保存到NVS，无论是否“脏”。
     * @details 用于在系统重启等关键操作前，确保所有配置都已持久化。
     */
    void forceSave();

    /**
     * @brief 检查是否有未保存的修改。
     * @return bool `true` 如果有未提交的修改，否则为 `false`。
     */
    bool isDirty();
    
    /**
     * @brief 将所有设置恢复到出厂默认值，并立即保存到NVS。
     */
    void factoryReset();

    // --- 线程安全的 Setter 接口 ---
    // 每个setter都会修改内存中的值，并设置“脏”标记，以待`commit()`。
    
    /** @brief 设置WiFi相关配置。*/
    void setWiFiConfig(const char* ssid, const char* password, SystemSettings::WiFiMode mode);
    /** @brief 设置蓝牙相关配置。*/
    void setBluetoothConfig(bool enabled, const char* name);
    /** @brief 设置运行时调试模式开关。*/
    void setDebugMode(bool enabled);

private:
    // 私有构造函数，在其中创建同步机制。
    Sys_SettingsManager();
    
    // 从NVS加载配置到内存缓存
    void load();
    // 将内存缓存中的配置保存到NVS
    bool save(); // [优化] 返回bool值，便于上层判断是否成功
    // 将出厂默认配置加载到内存缓存
    void loadDefaults();
    // 将“脏”标记设为true
    void markAsDirty();

    /** @brief 单例实例指针。*/
    static Sys_SettingsManager* _instance;
    /** @brief 内存中的配置缓存，是系统的“唯一事实来源”。*/
    SystemSettings _settings;
    /** @brief “脏”标记，指示内存中的配置是否与NVS中的不一致。*/
    bool _is_dirty = false;
    
    /** @brief 互斥锁，用于保护对 _settings 和 _is_dirty 的并发访问。*/
    SemaphoreHandle_t _mutex = NULL;
    
    /** @brief 用于存储配置的NVS命名空间。*/
    static constexpr const char* NVS_NAMESPACE = "sys_config";
    /** @brief 用于存储配置BLOB的NVS键名。*/
    static constexpr const char* NVS_KEY_BLOB = "settings_v1";
};


##### /**
 * @file Sys_SettingsManager.cpp
 * @brief 系统设置管理器的实现文件
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 * 
 * @details
 * 实现了从NVS加载、保存配置，以及版本控制和默认值恢复等核心逻辑。
 * 它完全依赖`Sys_NvsManager`作为其底层存储引擎，并使用互斥锁确保
 * 所有对配置缓存的读写操作都是线程安全的。
 */
#include "Sys_SettingsManager.h"
#include "Sys_NvsManager.h" // 依赖底层NVS工具类
#include "Sys_Debug.h"

/** @brief 当前固件期望的设置版本号。当`SystemSettings`结构体发生不兼容的改变时，必须增加此版本号。*/
static constexpr const uint32_t CURRENT_SETTINGS_VERSION = 1;

// 初始化静态单例指针
Sys_SettingsManager* Sys_SettingsManager::_instance = nullptr;

/**
 * @brief 私有构造函数，在此创建互斥锁。
 */
Sys_SettingsManager::Sys_SettingsManager() {
    _mutex = xSemaphoreCreateMutex();
    if (_mutex == NULL) {
        ESP_LOGE("Settings", "FATAL: Failed to create mutex!"); // 严重错误: 创建互斥锁失败！
    }
}

/**
 * @brief 获取Settings管理器的单例实例。
 */
Sys_SettingsManager* Sys_SettingsManager::getInstance() {
    // [优化] 此处采用的简单单例模式依赖于在单线程环境（setup()）中首次调用。
    // 这对于大多数嵌入式项目是足够且高效的。
    if (_instance == nullptr) {
        _instance = new Sys_SettingsManager();
    }
    return _instance;
}

/**
 * @brief 模块初始化，在系统启动时调用。
 */
void Sys_SettingsManager::begin() {
    DEBUG_LOG("Initializing Settings Manager...");
    // 调试日志: 正在初始化设置管理器...
    
    // 在begin()中，系统处于单线程模式，无需加锁即可安全调用load()
    load();
}

/**
 * @brief 从NVS加载配置到内存缓存。
 * @note 这是一个私有方法，假定它总是在一个已获取锁或单线程的上下文中被调用。
 */
void Sys_SettingsManager::load() {
    SystemSettings temp_settings;
    size_t blob_size = sizeof(SystemSettings);

    if (Sys_NvsManager::readBlob(NVS_NAMESPACE, NVS_KEY_BLOB, &temp_settings, &blob_size) && blob_size == sizeof(SystemSettings)) {
        // 读取成功，检查版本
        if (temp_settings.settings_version == CURRENT_SETTINGS_VERSION) {
            ESP_LOGI("Settings", "Settings v%u loaded from NVS.", temp_settings.settings_version);
            // 日志: 从NVS加载了v%u版本的设置。
            _settings = temp_settings;
            _is_dirty = false;
            return;
        } else {
            // 版本不匹配
            ESP_LOGW("Settings", "NVS version mismatch (found v%u, expected v%u). Restoring defaults.", temp_settings.settings_version, CURRENT_SETTINGS_VERSION);
            // 警告: NVS版本不匹配(发现v%u, 期望v%u)。正在恢复默认值。
            loadDefaults();
            save(); // 保存新的默认值
        }
    } else {
        // 读取失败 (通常是首次启动)
        ESP_LOGW("Settings", "Could not read settings. Loading and saving defaults.");
        // 警告: 无法读取设置。正在加载并保存默认值。
        loadDefaults();
        save();
    }
}

/**
 * @brief 将内存缓存中的配置保存到NVS。
 * @note 这是一个私有方法，假定它总是在一个已获取锁的上下文中被调用。
 * @return bool 是否保存成功。
 */
bool Sys_SettingsManager::save() {
    DEBUG_LOG("Saving settings to NVS...");
    // 调试日志: 正在保存设置到NVS...
    _settings.settings_version = CURRENT_SETTINGS_VERSION;

    if (Sys_NvsManager::writeBlob(NVS_NAMESPACE, NVS_KEY_BLOB, &_settings, sizeof(SystemSettings))) {
        ESP_LOGI("Settings", "Settings successfully committed to NVS.");
        // 日志: 设置已成功提交到NVS。
        _is_dirty = false;
        return true;
    } else {
        ESP_LOGE("Settings", "Failed to commit settings to NVS!");
        // 错误: 提交设置到NVS失败！
        return false;
    }
}

/**
 * @brief 提交内存中的修改到NVS（如果需要）。
 */
bool Sys_SettingsManager::commit() {
    Sys_LockGuard lock(_mutex);
    if (_is_dirty) {
        return save();
    }
    return true; // 没有修改，视为提交成功
}

/**
 * @brief 强制将内存配置写入NVS。
 */
void Sys_SettingsManager::forceSave() {
    Sys_LockGuard lock(_mutex);
    save();
}

/**
 * @brief 将出厂默认配置加载到内存缓存。
 * @note 这是一个私有方法，假定它总是在一个已获取锁的上下文中被调用。
 */
void Sys_SettingsManager::loadDefaults() {
    ESP_LOGI("Settings", "Loading default settings into memory.");
    // 日志: 正在加载默认设置到内存。
    _settings = SystemSettings(); // 使用默认构造函数重置
    markAsDirty();
}

/**
 * @brief 恢复出厂设置。
 */
void Sys_SettingsManager::factoryReset() {
    Sys_LockGuard lock(_mutex);
    ESP_LOGW("Settings", "Performing factory reset!");
    // 警告: 正在执行恢复出厂设置！
    Sys_NvsManager::eraseNamespace(NVS_NAMESPACE);
    loadDefaults();
    save();
}

/**
 * @brief 获取对配置缓存的安全拷贝。
 */
SystemSettings Sys_SettingsManager::getSettings() {
    Sys_LockGuard lock(_mutex);
    return _settings;
}

/**
 * @brief 检查配置是否“脏”。
 */
bool Sys_SettingsManager::isDirty() {
    Sys_LockGuard lock(_mutex);
    return _is_dirty;
}

/**
 * @brief 标记配置为“脏”。
 * @note 这是一个私有方法，假定它总是在一个已获取锁的上下文中被调用。
 */
void Sys_SettingsManager::markAsDirty() {
    if (!_is_dirty) {
        DEBUG_LOG("Settings marked as dirty.");
        _is_dirty = true;
    }
}

// --- 线程安全的 Getter 实现 ---

bool Sys_SettingsManager::isDebugModeEnabled() {
    Sys_LockGuard lock(_mutex);
    return _settings.debug_mode_enabled;
}

SystemSettings::WiFiMode Sys_SettingsManager::getWiFiMode() {
    Sys_LockGuard lock(_mutex);
    return _settings.wifi_mode;
}

String Sys_SettingsManager::getBluetoothName() {
    Sys_LockGuard lock(_mutex);
    return String(_settings.bluetooth_name);
}

// --- 线程安全的 Setter 实现 ---

void Sys_SettingsManager::setWiFiConfig(const char* ssid, const char* password, SystemSettings::WiFiMode mode) {
    Sys_LockGuard lock(_mutex);
    // 只有当配置实际发生变化时，才进行修改并标记为脏
    if (strcmp(_settings.wifi_ssid, ssid) != 0 || 
        strcmp(_settings.wifi_password, password) != 0 || 
        _settings.wifi_mode != mode) {
        
        strncpy(_settings.wifi_ssid, ssid, sizeof(_settings.wifi_ssid) - 1);
        _settings.wifi_ssid[sizeof(_settings.wifi_ssid) - 1] = '\0'; // 确保null结尾
        
        strncpy(_settings.wifi_password, password, sizeof(_settings.wifi_password) - 1);
        _settings.wifi_password[sizeof(_settings.wifi_password) - 1] = '\0';

        _settings.wifi_mode = mode;
        
        markAsDirty();
    }
}

/**
 * @brief 设置蓝牙配置。
 */
void Sys_SettingsManager::setBluetoothConfig(bool enabled, const char* name) {
    Sys_LockGuard lock(_mutex);
    if (_settings.bluetooth_enabled != enabled || strcmp(_settings.bluetooth_name, name) != 0) {
        _settings.bluetooth_enabled = enabled;
        strncpy(_settings.bluetooth_name, name, sizeof(_settings.bluetooth_name) - 1);
        _settings.bluetooth_name[sizeof(_settings.bluetooth_name) - 1] = '\0';
        markAsDirty();
    }
}

/**
 * @brief 设置运行时调试模式。
 */
void Sys_SettingsManager::setDebugMode(bool enabled) {
    Sys_LockGuard lock(_mutex);
    if (_settings.debug_mode_enabled != enabled) {
        _settings.debug_mode_enabled = enabled;
        markAsDirty();
    }
}


### Sys_NvsManager.h & .cpp  
//本模块的角色是一个底层的、静态的工具类，专门负责与NVS硬件的直接交互。

#### 高度专一服务于 Sys_SettingsManager 的底层工具类，提供类型安全的、带错误处理的NVS读写原子操作。

##### /**
 * @file Sys_NvsManager.h
 * @brief NVS（非易失性存储）底层操作工具类的接口定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 该模块提供了一组静态方法，用于对NVS进行类型安全的读写操作。
 * 它被设计为上层管理器（如 `Sys_SettingsManager`）的底层服务，
 * 封装了NVS句柄的打开、关闭以及详细的错误处理，使得上层逻辑更清晰。
 * 这个类不应该被实例化。
 */
#pragma once

#include <Arduino.h>
#include "nvs_flash.h"
#include "nvs.h"
#include <type_traits> // 用于 std::is_same

/**
 * @class Sys_NvsManager
 * @brief 一个提供类型安全的NVS读写操作的静态工具类。
 */
class Sys_NvsManager {
public:
    // 删除默认构造函数，明确表示这是一个纯静态工具类，禁止实例化。
    Sys_NvsManager() = delete;

    /**
     * @brief 初始化NVS分区。系统启动时必须调用一次。
     * @details 会处理NVS分区损坏或版本不兼容的情况，并在必要时擦除并重新初始化分区。
     * @return esp_err_t `ESP_OK` 表示成功。
     */
    static esp_err_t initialize();

    /**
     * @brief 从NVS中读取一个基本数据类型的值。
     * @tparam T 要读取的值的类型 (如 `uint8_t`, `int32_t`, `bool` 等)。
     * @param ns_name NVS命名空间 (Namespace)。
     * @param key 键名。
     * @param out_value 用于接收读取值的变量的引用。
     * @return bool `true` 表示成功, `false` 表示失败 (如键未找到或类型不匹配)。
     */
    template<typename T>
    static bool readValue(const char* ns_name, const char* key, T& out_value);

    /**
     * @brief 向NVS写入一个基本数据类型的值。
     * @details 操作完成后会自动提交 (commit)。
     * @tparam T 要写入的值的类型。
     * @param ns_name NVS命名空间。
     * @param key 键名。
     * @param value 要写入的值。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    template<typename T>
    static bool writeValue(const char* ns_name, const char* key, T value);

    /**
     * @brief 从NVS中读取一个字符串。
     * @param ns_name NVS命名空间。
     * @param key 键名。
     * @param out_buffer 用于接收字符串的缓冲区。
     * @param buffer_size 缓冲区的最大尺寸。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    static bool readString(const char* ns_name, const char* key, char* out_buffer, size_t buffer_size);

    /**
     * @brief 向NVS写入一个字符串。
     * @param ns_name NVS命名空间。
     * @param key 键名。
     * @param value 要写入的字符串。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    static bool writeString(const char* ns_name, const char* key, const char* value);
    
    /**
     * @brief 从NVS中读取一个二进制大数据块 (BLOB)。
     * @param ns_name NVS命名空间。
     * @param key 键名。
     * @param out_blob 用于接收数据的缓冲区指针。
     * @param length [in/out] 输入时表示缓冲区的最大容量，输出时表示实际读取的字节数。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    static bool readBlob(const char* ns_name, const char* key, void* out_blob, size_t* length);
    
    /**
     * @brief 向NVS写入一个二进制大数据块 (BLOB)。
     * @param ns_name NVS命名空间。
     * @param key 键名。
     * @param blob 要写入的数据的指针。
     * @param length 数据的长度。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    static bool writeBlob(const char* ns_name, const char* key, const void* blob, size_t length);
    
    /**
     * @brief 擦除指定命名空间下的所有键值对。
     * @warning 这是一个危险操作，会删除该命名空间下的所有数据。
     * @param ns_name 要擦除的命名空间。
     * @return bool `true` 表示成功, `false` 表示失败。
     */
    static bool eraseNamespace(const char* ns_name);
};

// --- 模板函数的实现必须放在头文件中 ---

/**
 * @brief `readValue` 模板函数的具体实现。
 * @details
 *  - 使用 `std::is_same` 来进行类型判断，并在编译时确定要调用哪个nvs_get_...函数。
 *  - 对 `bool` 类型进行了特殊处理，通过 `uint8_t` 进行存储和读取。
 */
template<typename T>
bool Sys_NvsManager::readValue(const char* ns_name, const char* key, T& out_value) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        // 如果打开命名空间失败，直接返回false。
        return false;
    }

    // 使用if-constexpr (C++17) 或 std::is_same (C++11) 进行类型分发
    if (std::is_same<T, uint8_t>::value)       err = nvs_get_u8(nvs_handle, key, reinterpret_cast<uint8_t*>(&out_value));
    else if (std::is_same<T, int8_t>::value)   err = nvs_get_i8(nvs_handle, key, reinterpret_cast<int8_t*>(&out_value));
    else if (std::is_same<T, uint16_t>::value) err = nvs_get_u16(nvs_handle, key, reinterpret_cast<uint16_t*>(&out_value));
    else if (std::is_same<T, int16_t>::value)  err = nvs_get_i16(nvs_handle, key, reinterpret_cast<int16_t*>(&out_value));
    else if (std::is_same<T, uint32_t>::value) err = nvs_get_u32(nvs_handle, key, reinterpret_cast<uint32_t*>(&out_value));
    else if (std::is_same<T, int32_t>::value)  err = nvs_get_i32(nvs_handle, key, reinterpret_cast<int32_t*>(&out_value));
    else if (std::is_same<T, uint64_t>::value) err = nvs_get_u64(nvs_handle, key, reinterpret_cast<uint64_t*>(&out_value));
    else if (std::is_same<T, int64_t>::value)  err = nvs_get_i64(nvs_handle, key, reinterpret_cast<int64_t*>(&out_value));
    else if (std::is_same<T, bool>::value) {
        uint8_t val = 0;
        err = nvs_get_u8(nvs_handle, key, &val);
        if (err == ESP_OK) {
            *reinterpret_cast<bool*>(&out_value) = (val != 0);
        }
    } else {
        // 如果传入了不支持的类型，返回类型不匹配错误。
        err = ESP_ERR_NVS_TYPE_MISMATCH;
    }

    nvs_close(nvs_handle);
    return err == ESP_OK;
}

/**
 * @brief `writeValue` 模板函数的具体实现。
 */
template<typename T>
bool Sys_NvsManager::writeValue(const char* ns_name, const char* key, T value) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) return false;

    if (std::is_same<T, uint8_t>::value)       err = nvs_set_u8(nvs_handle, key, *reinterpret_cast<const uint8_t*>(&value));
    else if (std::is_same<T, int8_t>::value)   err = nvs_set_i8(nvs_handle, key, *reinterpret_cast<const int8_t*>(&value));
    else if (std::is_same<T, uint16_t>::value) err = nvs_set_u16(nvs_handle, key, *reinterpret_cast<const uint16_t*>(&value));
    else if (std::is_same<T, int16_t>::value)  err = nvs_set_i16(nvs_handle, key, *reinterpret_cast<const int16_t*>(&value));
    else if (std::is_same<T, uint32_t>::value) err = nvs_set_u32(nvs_handle, key, *reinterpret_cast<const uint32_t*>(&value));
    else if (std::is_same<T, int32_t>::value)  err = nvs_set_i32(nvs_handle, key, *reinterpret_cast<const int32_t*>(&value));
    else if (std::is_same<T, uint64_t>::value) err = nvs_set_u64(nvs_handle, key, *reinterpret_cast<const uint64_t*>(&value));
    else if (std::is_same<T, int64_t>::value)  err = nvs_set_i64(nvs_handle, key, *reinterpret_cast<const int64_t*>(&value));
    else if (std::is_same<T, bool>::value)     err = nvs_set_u8(nvs_handle, key, static_cast<uint8_t>(*reinterpret_cast<const bool*>(&value)));
    else {
        err = ESP_ERR_NVS_TYPE_MISMATCH;
    }

    // 只有在set操作成功后，才执行commit操作。
    if (err == ESP_OK) {
        err = nvs_commit(nvs_handle);
    }

    nvs_close(nvs_handle);
    return err == ESP_OK;
}

##### /**
 * @file Sys_NvsManager.cpp
 * @brief NVS底层操作工具类的实现文件
 * @author [ANEAK]
 * @date [2025/7]
 * 
 * @details
 * 实现了`Sys_NvsManager`中所有非模板静态方法的具体逻辑。
 */
#include "Sys_NvsManager.h"
#include "Sys_Debug.h" // 使用我们自己的调试宏

/**
 * @brief 初始化NVS分区。
 */
esp_err_t Sys_NvsManager::initialize() {
    esp_err_t err = nvs_flash_init();
    // 当NVS分区已满或发现一个不兼容的旧版本时，最好的做法是擦除它。
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW("NVS", "NVS partition contains no free pages or is a new version, erasing...");
        // 警告: NVS分区无空闲页或版本不兼容，正在擦除...
        ESP_ERROR_CHECK(nvs_flash_erase()); // 擦除NVS分区
        err = nvs_flash_init(); // 再次尝试初始化
    }
    ESP_ERROR_CHECK(err); // 检查最终的初始化结果，如果失败则会panic
    
    if (err == ESP_OK) {
        DEBUG_LOG("NVS storage initialized successfully."); // 调试日志: NVS存储初始化成功。
    }
    return err;
}

/**
 * @brief 读取一个字符串。
 */
bool Sys_NvsManager::readString(const char* ns_name, const char* key, char* out_buffer, size_t buffer_size) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) return false;

    // nvs_get_str会处理字符串长度和缓冲区的匹配
    err = nvs_get_str(nvs_handle, key, out_buffer, &buffer_size);
    
    nvs_close(nvs_handle);
    return err == ESP_OK;
}

/**
 * @brief 写入一个字符串。
 */
bool Sys_NvsManager::writeString(const char* ns_name, const char* key, const char* value) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) return false;

    err = nvs_set_str(nvs_handle, key, value);
    if (err == ESP_OK) {
        err = nvs_commit(nvs_handle);
    }

    nvs_close(nvs_handle);
    return err == ESP_OK;
}

/**
 * @brief 读取一个二进制数据块 (BLOB)。
 */
bool Sys_NvsManager::readBlob(const char* ns_name, const char* key, void* out_blob, size_t* length) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) return false;

    // nvs_get_blob会处理长度检查
    err = nvs_get_blob(nvs_handle, key, out_blob, length);

    nvs_close(nvs_handle);
    return err == ESP_OK;
}

/**
 * @brief 写入一个二进制数据块 (BLOB)。
 */
bool Sys_NvsManager::writeBlob(const char* ns_name, const char* key, const void* blob, size_t length) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) return false;
    
    err = nvs_set_blob(nvs_handle, key, blob, length);
    if (err == ESP_OK) {
        err = nvs_commit(nvs_handle);
    }

    nvs_close(nvs_handle);
    return err == ESP_OK;
}

/**
 * @brief 擦除整个命名空间。
 */
bool Sys_NvsManager::eraseNamespace(const char* ns_name) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(ns_name, NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("NVS", "Failed to open namespace '%s' for erasing.", ns_name);
        return false;
    }

    err = nvs_erase_all(nvs_handle);
    if(err == ESP_OK) {
        err = nvs_commit(nvs_handle);
    }
    
    nvs_close(nvs_handle);
    
    if (err != ESP_OK) {
        ESP_LOGE("NVS", "Failed to erase or commit namespace '%s'.", ns_name);
    } else {
        ESP_LOGI("NVS", "Namespace '%s' erased successfully.", ns_name);
    }
    
    return err == ESP_OK;
}


### Sys_MemoryManager.h & .cpp 
//本模块是解决PSRAM碎片化问题的核心，其设计和实现都非常关键。

#### - 封装PSRAM管理：将所有与PSRAM直接交互的底层细节（如heap_caps_malloc）都封装在内部，对其他模块隐藏这些复杂性。

- 提供多池内存管理器：这不再是一个简单的malloc包装器，而是一个主动的、有策略的内存管理器。它通过预先分配、分池管理的方式，来解决PSRAM最大的痛点——内存碎片化。

##### /**
 * @file Sys_MemoryManager.h
 * @brief 系统内存管理器的接口定义 (基于ESP-IDF多堆)
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 *  该模块采用ESP-IDF v5.x先进的多堆（Multi-heap）内存管理方案。
 *  它在系统启动时，从PSRAM中划分出一块专用区域，并将其注册为一个
 *  隔离的、具有自定义能力（MALLOC_CAP_FRAMEBUFFER）的新堆。
 *  这种方法为关键任务（如摄像头）提供了稳定、隔离的大块内存，
 *  同时保留了标准`heap_caps_malloc`的灵活性。
 *
 * @note  本模块的所有公共方法均为线程安全。
 */
#pragma once

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "Sys_LockGuard.h" // 引入RAII锁

/**
 * @class Sys_MemoryManager
 * @brief 一个基于ESP-IDF多堆模型的内存管理器。
 */
class Sys_MemoryManager {
public:
    /**
     * @brief 获取内存管理器的单例实例。
     * @note  必须在系统进入多任务调度前（如在setup()中）完成首次调用。
     * @return Sys_MemoryManager* 指向唯一实例的指针。
     */
    static Sys_MemoryManager* getInstance();

    // 删除拷贝构造函数和赋值操作符，确保单例模式。
    Sys_MemoryManager(const Sys_MemoryManager&) = delete;
    Sys_MemoryManager& operator=(const Sys_MemoryManager&) = delete;

    /**
     * @brief 在系统启动时调用，创建并注册专用的PSRAM堆。
     * @details 此函数将从主PSRAM堆中分配一块大内存，并将其注册为具有
     *          `MALLOC_CAP_FRAMEBUFFER`能力的新堆，供特定任务使用。
     * @return bool `true` 如果专用堆初始化成功, `false` 如果失败。
     */
    bool initializePools();

    /**
     * @brief 释放一个之前通过`heap_caps_malloc`分配的内存块。
     * @details 线程安全。这只是对`heap_caps_free`的简单封装，以保持接口统一。
     * @param block_ptr 指向要释放的内存的指针。
     */
    void releaseMemoryBlock(void* block_ptr);
    
    /**
     * @brief 打印所有关键堆的当前使用状态，用于调试。
     * @details 线程安全。
     */
    void printMemoryInfo();

private:
    // 私有构造函数
    Sys_MemoryManager();

    /** @brief 单例实例指针。*/
    static Sys_MemoryManager* _instance;

    /** @brief 互斥锁，用于保护对内存信息打印等共享操作的并发访问。*/
    SemaphoreHandle_t _mutex = NULL;
};


##### /**
 * @file Sys_MemoryManager.cpp
 * @brief 混合内存管理器的实现 (ESP-IDF多堆 + 专用堆)
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 *  本文件根据您的专业建议，实现了混合式内存管理策略。
 *  核心思想是：
 *  1. 利用ESP-IDF强大的多堆（Multi-heap）功能作为基础。
 *  2. 手动从PSRAM中划分出一块专用的大块内存区域。
 *  3. 使用 `heap_caps_add_region` 将这块区域注册为一个新的、隔离的堆，
 *     专门用于可预见的大块内存分配（如摄像头帧缓冲）。
 *  这种方法兼具灵活性和稳定性，是本项目内存管理的最终方案。
 */

#include "Sys_MemoryManager.h"
#include "Sys_Debug.h"
#include "esp_heap_caps.h"

// --- 内存能力定义 ---
// 定义一个自定义的内存能力标志，用于从我们专用的帧缓冲堆中分配内存。
// 这使得代码意图非常明确：heap_caps_malloc(size, MALLOC_CAP_FRAMEBUFFER);
// #define MALLOC_CAP_FRAMEBUFFER (1 << 25) // [移除] 自定义能力标志依赖已废弃的API

// --- 专用堆配置 ---
// 定义为摄像头帧缓冲准备的专用堆的大小 (例如 3MB)
// 1920 * 1080 * 2 (YUY2) = 4,147,200 字节 ≈ 4MB
// 考虑到可能的裕量，我们分配4MB
static const size_t FRAMEBUFFER_HEAP_SIZE = 4 * 1024 * 1024; 
static void* _framebuffer_heap_start = nullptr;

// 初始化静态单例指针
Sys_MemoryManager* Sys_MemoryManager::_instance = nullptr;

/**
 * @brief 获取内存管理器的单例实例。
 */
Sys_MemoryManager* Sys_MemoryManager::getInstance() {
    if (_instance == nullptr) {
        // 在多任务启动前调用，此处无需加锁
        _instance = new Sys_MemoryManager();
    }
    return _instance;
}

/**
 * @brief 私有构造函数，创建互斥锁。
 */
Sys_MemoryManager::Sys_MemoryManager() {
    _mutex = xSemaphoreCreateMutex();
    if (_mutex == NULL) {
        ESP_LOGE("MemManager", "Fatal: Failed to create mutex!");
    }
}

/**
 * @brief 初始化内存管理器，创建并注册专用堆。
 * @details
 *  这是内存管理的核心初始化函数。它会从主PSRAM堆中分配一大块内存，
 *  然后将其注册为一个带有`MALLOC_CAP_FRAMEBUFFER`能力的新堆。
 * @return bool `true` 如果专用堆创建并注册成功, `false` 否则。
 */
bool Sys_MemoryManager::initializePools() {
    DEBUG_LOG("Initializing Memory Manager with dedicated Framebuffer Heap...");

    // 1. 从PSRAM中为我们的专用堆分配内存
    _framebuffer_heap_start = heap_caps_malloc(FRAMEBUFFER_HEAP_SIZE, MALLOC_CAP_SPIRAM);

    if (_framebuffer_heap_start == nullptr) {
        ESP_LOGE("MemManager", "Fatal: Failed to allocate %d bytes for Framebuffer Heap from PSRAM!", FRAMEBUFFER_HEAP_SIZE);
        return false;
    }
    
    // [待办] ESP-IDF v5.x 中 heap_caps_add_region_with_caps 已被移除。
    // 暂时只分配内存，不注册为新堆，以确保编译通过。
    // 后续可研究使用 esp_heap_add_region 等底层API实现真正的隔离。
    ESP_LOGI("MemManager", "Successfully allocated %dMB for Framebuffer from PSRAM.", FRAMEBUFFER_HEAP_SIZE / (1024 * 1024));
    printMemoryInfo(); // 打印初始内存信息
    return true;
}


/**
 * @brief 释放一个之前分配的内存块。
 * @details 在新的模型中，这只是对 `heap_caps_free` 的简单封装。
 * @param block_ptr 指向通过 `heap_caps_malloc` 分配的内存的指针。
 */
void Sys_MemoryManager::releaseMemoryBlock(void* block_ptr) {
    if (block_ptr == nullptr) return;
    // 在多堆模型中，只需调用标准的free即可，系统会自动处理
    heap_caps_free(block_ptr);
}

/**
 * @brief 打印所有关键堆的当前使用状态，用于调试。
 */
void Sys_MemoryManager::printMemoryInfo() {
    Sys_LockGuard lock(_mutex);
    ESP_LOGI("MemManager", "--- System Heap Info ---");

    multi_heap_info_t info;
    
    // 打印默认内部SRAM堆信息
    heap_caps_get_info(&info, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
    ESP_LOGI("MemManager", "SRAM Heap: Free=%d, MinFree=%d, LargestFree=%d",
             info.total_free_bytes, info.minimum_free_bytes, info.largest_free_block);

    // 打印默认外部PSRAM堆信息
    heap_caps_get_info(&info, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    ESP_LOGI("MemManager", "PSRAM Heap (General): Free=%d, MinFree=%d, LargestFree=%d",
             info.total_free_bytes, info.minimum_free_bytes, info.largest_free_block);

    // 由于注册专用堆的API已更改，我们暂时无法获取其独立信息
    if (_framebuffer_heap_start) {
        ESP_LOGI("MemManager", "A %dMB block for framebuffer has been allocated from PSRAM.", FRAMEBUFFER_HEAP_SIZE / (1024*1024));
    }
    
    ESP_LOGI("MemManager", "------------------------");
}


### Sys_Tasks.h & .cpp  
//封装为任务管理器，是集中管理、清晰定义、易于监控的系统组件工厂。

#### - 集中化管理: 所有任务的创建、参数（堆栈大小、优先级）的定义都集中在起，便于统一调整和概览。

- 封装为类方法: 将每个任务的loop函数封装为类的静态私有方法，避免了全局函数的污染，保持了代码的组织性。

清晰的职责: Sys_Tasks只负责“启动和管理任务”，而任务的具体业务逻辑则委托给其他管理器（如Sys_WiFiManager），符合关注点分离原则。

- 通信句柄传递: 在启动任务时，将必要的通信句柄（如队列、事件组）作为参数传递进去，实现了任务间的解耦。集中化管理: 所有任务的创建、参数（堆栈大小、优先级）的定义都集中在一个地方，便于统一调整和概览。

- 封装为类方法: 将每个任务的loop函数封装为类的静态私有方法，避免了全局函数的污染，保持了代码的组织性。

- 清晰的职责: Sys_Tasks只负责“启动和管理任务”，而任务的具体业务逻辑则委托给其他管理器（如Sys_WiFiManager），符合关注点分离原则。

-通信句柄传递: 在启动任务时，将必要的通信句柄（如队列、事件组）作为参数传递进去，实现了任务间的解耦。

##### /**
 * @file Sys_Tasks.h
 * @brief 系统核心任务管理器的接口定义
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 *
 * @details
 * 该文件是系统中所有FreeRTOS后台任务的“蓝图”。
 * 它集中定义了每个任务的属性（名称、堆栈、优先级、核心），
 * 并声明了任务间通信所需的全局句柄，为整个系统的并发模型
 * 提供了清晰、统一的视图。
 * 优化点：
 * 1. 明确了任务看门狗(TWDT)的配置和使用。
 * 2. 增加了对未来任务(Task_ImageProcessor)的规划。
 */
#pragma once

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"
#include "ESPAsyncWebServer.h" // 需要 AsyncWebSocket 类型

// --- 定义全局通信句柄 ---
// 这些句柄在Sys_Tasks.cpp中被实际创建，在此处用`extern`声明以便其他模块可以引用。
// 它们是任务间通信的桥梁，实现了模块间的解耦。

/** @brief 命令队列：用于从前端接口（如WebServer）接收待处理的命令，由Task_Worker消费。*/
extern QueueHandle_t xCommandQueue;
/** @brief 状态队列：用于从后台任务（如Task_SystemMonitor）收集需要推送到前端的状态信息。*/
extern QueueHandle_t xStateQueue;
/** @brief 数据事件组：用于高效地通知Task_WebSocketPusher有新的数据需要推送，避免轮询队列。*/
extern EventGroupHandle_t xDataEventGroup;

// --- 事件组中的事件位定义 ---
/** @brief 标记`xStateQueue`中有新数据的事件位。*/
const EventBits_t BIT_STATE_QUEUE_READY = (1 << 0);
/** @brief 标记日志队列（未来扩展）中有新数据的事件位。*/
const EventBits_t BIT_LOG_QUEUE_READY   = (1 << 1);
// ... 未来可在此添加其他事件位 ...


/**
 * @class Sys_Tasks
 * @brief 集中创建和管理系统中的所有FreeRTOS任务。
 *        它是一个任务工厂和管理器，负责启动系统的并发核心。
 */
class Sys_Tasks {
public:
    /**
     * @brief 初始化所有通信句柄并创建所有系统任务。
     * @details 这是从单线程`setup()`到多任务系统的切换点。
     *          此函数还会初始化并启动任务看门狗。
     * @param webSocket 异步WebSocket服务器的实例指针，用于安全地传递给需要它的后台任务。
     */
    static void begin(AsyncWebSocket* webSocket);

private:
    // --- 任务参数定义 ---
    // 将所有任务的配置参数集中在此处，便于统一调整和管理。

    /** @brief Task_Worker: 命令处理器任务 */
    static constexpr const char* TASK_WORKER_NAME = "Task_Worker";
    static constexpr uint32_t TASK_WORKER_STACK_SIZE = 4096;
    static constexpr UBaseType_t TASK_WORKER_PRIORITY = 1;
    static constexpr BaseType_t TASK_WORKER_CORE = 1;

    /** @brief Task_SystemMonitor: 系统监视器任务 */
    static constexpr const char* TASK_MONITOR_NAME = "Task_SystemMonitor";
    static constexpr uint32_t TASK_MONITOR_STACK_SIZE = 4096;
    static constexpr UBaseType_t TASK_MONITOR_PRIORITY = 1;
    static constexpr BaseType_t TASK_MONITOR_CORE = 1;

    /** @brief Task_WebSocketPusher: WebSocket推送器任务 */
    static constexpr const char* TASK_PUSHER_NAME = "Task_WebSocketPusher";
    static constexpr uint32_t TASK_PUSHER_STACK_SIZE = 4096;
    static constexpr UBaseType_t TASK_PUSHER_PRIORITY = 2; // 较高优先级，确保数据实时推送
    static constexpr BaseType_t TASK_PUSHER_CORE = 1;      // 在应用核心上运行

    // --- 任务的静态循环函数 ---
    // 声明为私有，防止外部直接调用，其地址被传递给`xTaskCreatePinnedToCore`。
    
    /** @brief Task_Worker 的核心循环函数。*/
    static void taskWorkerLoop(void* parameter);
    /** @brief Task_SystemMonitor 的核心循环函数。*/
    static void taskSystemMonitorLoop(void* parameter);
    /** @brief Task_WebSocketPusher 的核心循环函数。*/
    static void taskWebSocketPusherLoop(void* parameter);

    // --- [重构] JSON RPC 请求的统一处理入口 ---
    /**
     * @brief 解析并分发JSON RPC请求到具体的处理逻辑。
     * @param request 包含RPC方法和参数的请求对象。
     */
    static void processJsonRpcRequest(const struct JsonRpcRequest& request);
};


##### /**
 * @file Sys_Tasks.cpp
 * @brief 系统核心任务的实现文件
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 *
 * @details
 * 该文件集中实现了项目中所有的后台FreeRTOS任务，并引入了任务看门狗(TWDT)
 * 机制来监控关键任务的健康状况，提升系统的健壮性。
 * 它扮演着系统“神经中枢”的角色，负责：
 * 1. 初始化任务间通信所需的所有句柄（Queues, Event Groups）。
 * 2. 创建并启动所有后台任务，并将它们固定在指定的CPU核心上。
 * 3. 定义每个任务的核心循环逻辑，协调各个管理器模块完成具体工作。
 */

#include "Sys_Tasks.h"
#include "types.h"
#include "Sys_Debug.h"

// --- 模块依赖 ---
#include "Sys_SettingsManager.h"
#include "Sys_WiFiManager.h"
#include "Sys_BlueToothManager.h"
#include "Sys_Diagnostics.h"

// --- 第三方库依赖 ---
#include "ArduinoJson.h"

// --- ESP-IDF 核心依赖 ---
#include "esp_task_wdt.h" // [优化] 引入任务看门狗头文件

// --- 全局通信句柄的定义 ---
QueueHandle_t xCommandQueue = NULL;
QueueHandle_t xStateQueue = NULL;
EventGroupHandle_t xDataEventGroup = NULL;

// [优化] 定义看门狗超时时间（秒）
static constexpr const uint32_t TASK_WDT_TIMEOUT_S = 15;

/**
 * @brief 初始化所有通信句柄、看门狗并创建所有系统任务。
 */
void Sys_Tasks::begin(AsyncWebSocket* webSocket) {
    DEBUG_LOG("Initializing system tasks and communication handles...");

    // 步骤 1: 创建通信句柄
    xCommandQueue = xQueueCreate(10, sizeof(JsonRpcRequest));
    xStateQueue = xQueueCreate(20, sizeof(char[1024]));
    xDataEventGroup = xEventGroupCreate();

    if (!xCommandQueue || !xStateQueue || !xDataEventGroup) {
        ESP_LOGE("Tasks", "FATAL: Failed to create communication handles!");
        return;
    }

    // 步骤 2: [优化] 初始化任务看门狗
    ESP_LOGI("Tasks", "Initializing Task Watchdog Timer with %d seconds timeout.", TASK_WDT_TIMEOUT_S);
    ESP_ERROR_CHECK(esp_task_wdt_init(TASK_WDT_TIMEOUT_S, true)); // true 表示 panic on timeout
    
    // 订阅当前任务(setup/loop)到看门狗，防止在任务启动前超时
    ESP_ERROR_CHECK(esp_task_wdt_add(NULL)); 
    esp_task_wdt_reset();

    // 步骤 3: 创建并启动所有后台任务
    TaskHandle_t worker_handle;
    xTaskCreatePinnedToCore(taskWorkerLoop, TASK_WORKER_NAME, TASK_WORKER_STACK_SIZE, NULL, TASK_WORKER_PRIORITY, &worker_handle, TASK_WORKER_CORE);
    xTaskCreatePinnedToCore(taskSystemMonitorLoop, TASK_MONITOR_NAME, TASK_MONITOR_STACK_SIZE, NULL, TASK_MONITOR_PRIORITY, NULL, TASK_MONITOR_CORE);
    xTaskCreatePinnedToCore(taskWebSocketPusherLoop, TASK_PUSHER_NAME, TASK_PUSHER_STACK_SIZE, (void*)webSocket, TASK_PUSHER_PRIORITY, NULL, TASK_PUSHER_CORE);
    
    // [优化] 将关键的Task_Worker注册到看门狗
    ESP_ERROR_CHECK(esp_task_wdt_add(worker_handle));

    ESP_LOGI("Tasks", "All system tasks created successfully.");

    // 取消订阅当前任务(setup/loop)，因为它的生命周期即将结束
    esp_task_wdt_delete(NULL);
}

// =================================================================================================
// 任务循环实现 (Task Loop Implementations)
// =================================================================================================

/**
 * @brief Task_Worker 的核心循环函数。
 * @details
 *  - 这是一个被看门狗监控的关键任务。
 *  - 它永远阻塞等待新命令，收到后分发给具体的处理函数。
 */
void Sys_Tasks::taskWorkerLoop(void* parameter) {
    ESP_LOGI(TASK_WORKER_NAME, "Task starting... Now monitored by TWDT.");
    JsonRpcRequest request;

    for (;;) {
        // [优化] 每次循环前“喂狗”，表示任务还活着
        esp_task_wdt_reset();

        if (xQueueReceive(xCommandQueue, &request, portMAX_DELAY) == pdPASS) {
            DEBUG_LOG("Worker received RPC method: %s from client #%u", request.method, request.client_id);
            processJsonRpcRequest(request);
        }
    }
}


/**
 * @brief Task_SystemMonitor 的核心循环函数。
 */
void Sys_Tasks::taskSystemMonitorLoop(void* parameter) {
    ESP_LOGI(TASK_MONITOR_NAME, "Task starting...");
    const TickType_t xFrequency = pdMS_TO_TICKS(1000);
    TickType_t xLastWakeTime = xTaskGetTickCount();

    for (;;) {
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
        DEBUG_LOG("System Monitor tick...");

        // 1. 更新WiFi状态机
        Sys_WiFiManager::getInstance()->update();
        
        // 2. 更新蓝牙状态机
        Sys_BlueToothManager::getInstance()->update();

        // 3. 提交“脏”的设置
        Sys_SettingsManager::getInstance()->commit();

        // 4. 采集系统状态并打包JSON
        // 4. 采集系统状态并打包为JSON RPC 2.0通知
        JsonDocument doc;
        doc["jsonrpc"] = "2.0";
        doc["method"] = "system.stateUpdate";
        JsonObject params = doc["params"].to<JsonObject>();
        params["uptime"] = millis();
        params["free_heap"] = ESP.getFreeHeap();
        params["free_psram"] = ESP.getFreePsram();
        params["wifi_state"] = (int)Sys_WiFiManager::getInstance()->getCurrentState();

        char jsonBuffer[512];
        serializeJson(doc, jsonBuffer, sizeof(jsonBuffer));

        // [优化] 检查队列发送结果
        if (xQueueSend(xStateQueue, &jsonBuffer, pdMS_TO_TICKS(10)) != pdPASS) {
            ESP_LOGW(TASK_MONITOR_NAME, "State queue is full. Status update dropped.");
        } else {
            xEventGroupSetBits(xDataEventGroup, BIT_STATE_QUEUE_READY);
        }
    }
}

/**
 * @brief Task_WebSocketPusher 的核心循环函数。
 */
void Sys_Tasks::taskWebSocketPusherLoop(void* parameter) {
    ESP_LOGI(TASK_PUSHER_NAME, "Task starting...");
    AsyncWebSocket* webSocket = (AsyncWebSocket*)parameter;

    if (!webSocket) {
        ESP_LOGE(TASK_PUSHER_NAME, "FATAL: WebSocket instance is NULL!");
        vTaskDelete(NULL);
    }
    
    char messageBuffer[1024];

    for (;;) {
        const EventBits_t bits = xEventGroupWaitBits(
            xDataEventGroup,
            BIT_STATE_QUEUE_READY | BIT_LOG_QUEUE_READY,
            pdTRUE, pdFALSE, portMAX_DELAY);

        // [优化] 只有在有客户端连接时才处理推送
        if (webSocket->count() == 0) {
            // 清空队列，防止消息堆积
            while (xQueueReceive(xStateQueue, &messageBuffer, 0) == pdPASS) {}
            continue; // 跳过本次推送
        }

        if (bits & BIT_STATE_QUEUE_READY) {
            DEBUG_LOG("Pusher woken by state queue event.");
            while (xQueueReceive(xStateQueue, &messageBuffer, 0) == pdPASS) {
                // 检查消息是响应还是通知
                JsonDocument doc;
                deserializeJson(doc, messageBuffer);
                if (!doc["id"].isNull()) { // 这是一个响应
                    uint32_t client_id = doc["client_id"];
                    doc.remove("client_id"); // 从最终发送的JSON中移除内部client_id
                    String response;
                    serializeJson(doc, response);
                    webSocket->text(client_id, response);
                } else { // 这是一个通知
                    webSocket->textAll(messageBuffer);
                }
            }
        }

        if (bits & BIT_LOG_QUEUE_READY) {
            // ... 未来的日志队列处理逻辑 ...
        }
    }
}


// =================================================================================================
// 命令处理函数实现 (Command Handler Implementations)
// =================================================================================================

/**
 * @brief 响应一个JSON RPC请求的辅助函数。
 * @param request 原始请求，用于获取id和client_id。
 * @param result 要包含在响应中的`result`字段的JSON文档。
 */
static void sendRpcResult(const JsonRpcRequest& request, JsonDocument& result) {
    JsonDocument response_doc;
    response_doc["jsonrpc"] = "2.0";
    response_doc["result"] = result.as<JsonVariant>();
    response_doc["id"] = request.id;
    response_doc["client_id"] = request.client_id; // 内部使用，用于pusher任务路由

    char jsonBuffer[1024];
    serializeJson(response_doc, jsonBuffer, sizeof(jsonBuffer));
    if (xQueueSend(xStateQueue, &jsonBuffer, 0) == pdPASS) {
        xEventGroupSetBits(xDataEventGroup, BIT_STATE_QUEUE_READY);
    } else {
        ESP_LOGW(TASK_WORKER_NAME, "State queue full. RPC response dropped for method %s.", request.method);
    }
}

/**
 * @brief 响应一个JSON RPC错误的辅助函数。
 */
static void sendRpcError(const JsonRpcRequest& request, int code, const char* message) {
    JsonDocument response_doc;
    response_doc["jsonrpc"] = "2.0";
    JsonObject error_obj = response_doc["error"].to<JsonObject>();
    error_obj["code"] = code;
    error_obj["message"] = message;
    response_doc["id"] = request.id;
    response_doc["client_id"] = request.client_id;

    char jsonBuffer[256];
    serializeJson(response_doc, jsonBuffer, sizeof(jsonBuffer));
    if (xQueueSend(xStateQueue, &jsonBuffer, 0) == pdPASS) {
        xEventGroupSetBits(xDataEventGroup, BIT_STATE_QUEUE_READY);
    }
}


void Sys_Tasks::processJsonRpcRequest(const JsonRpcRequest& request) {
    JsonDocument params_doc;
    deserializeJson(params_doc, request.params);

    // --- 系统命令 ---
    if (strcmp(request.method, "system.reboot") == 0) {
        JsonDocument result_doc;
        result_doc["status"] = "rebooting";
        sendRpcResult(request, result_doc);
        delay(1000);
        ESP.restart();
    }
    else if (strcmp(request.method, "system.factoryReset") == 0) {
        JsonDocument result_doc;
        result_doc["status"] = "resetting";
        sendRpcResult(request, result_doc);
        Sys_SettingsManager::getInstance()->factoryReset();
        delay(1000);
        ESP.restart();
    }
    // --- 设置管理 ---
    else if (strcmp(request.method, "settings.get") == 0) {
        const auto& settings = Sys_SettingsManager::getInstance()->getSettings();
        JsonDocument result_doc;
        JsonObject wifi_obj = result_doc["wifi"].to<JsonObject>();
        wifi_obj["ssid"] = settings.wifi_ssid;
        wifi_obj["mode"] = (int)settings.wifi_mode;
        JsonObject bt_obj = result_doc["bluetooth"].to<JsonObject>();
        bt_obj["deviceName"] = settings.bluetooth_name;
        bt_obj["enabled"] = settings.bluetooth_enabled;
        sendRpcResult(request, result_doc);
    }
    else if (strcmp(request.method, "settings.saveWiFi") == 0) {
        const char* ssid = params_doc["ssid"];
        const char* password = params_doc["password"];
        if (ssid) {
            Sys_SettingsManager::getInstance()->setWiFiConfig(ssid, password ? password : "", (SystemSettings::WiFiMode)params_doc["mode"].as<int>());
            Sys_WiFiManager::getInstance()->applySettings();
            JsonDocument result_doc;
            result_doc["status"] = "success";
            sendRpcResult(request, result_doc);
        } else {
            sendRpcError(request, -32602, "Invalid params: missing ssid");
        }
    }
    else if (strcmp(request.method, "settings.saveBluetooth") == 0) {
        const char* name = params_doc["deviceName"];
        if (name) {
            Sys_SettingsManager::getInstance()->setBluetoothConfig(params_doc["enabled"], name);
            Sys_BlueToothManager::getInstance()->applySettings();
            JsonDocument result_doc;
            result_doc["status"] = "success";
            sendRpcResult(request, result_doc);
        } else {
            sendRpcError(request, -32602, "Invalid params: missing deviceName");
        }
    }
    // --- WiFi管理 ---
    else if (strcmp(request.method, "wifi.scan") == 0) {
        JsonDocument result_doc;
        result_doc["status"] = "scanning";
        sendRpcResult(request, result_doc); // 立即响应，告知客户端扫描已开始

        int n = WiFi.scanNetworks(false, true);
        ESP_LOGI(TASK_WORKER_NAME, "Scan finished. Found %d networks.", n);

        JsonDocument scan_result_doc;
        scan_result_doc["jsonrpc"] = "2.0";
        scan_result_doc["method"] = "wifi.scanResult";
        JsonArray networks = scan_result_doc["params"].to<JsonArray>();
        for (int i = 0; i < n; ++i) {
            JsonObject net = networks.add<JsonObject>();
            net["ssid"] = WiFi.SSID(i);
            net["rssi"] = WiFi.RSSI(i);
            net["auth"] = WiFi.encryptionType(i);
        }
        
        char jsonBuffer[1024];
        serializeJson(scan_result_doc, jsonBuffer, sizeof(jsonBuffer));
        if (xQueueSend(xStateQueue, &jsonBuffer, 0) == pdPASS) {
            xEventGroupSetBits(xDataEventGroup, BIT_STATE_QUEUE_READY);
        } else {
            ESP_LOGW(TASK_WORKER_NAME, "State queue full. WiFi scan result dropped.");
        }
        WiFi.scanDelete();
    }
    // --- 调试命令 ---
    #if CORE_DEBUG_MODE
    else if (strcmp(request.method, "debug.runDiagnostics") == 0) {
        ESP_LOGI(TASK_WORKER_NAME, "Processing RUN_DIAGNOSTICS command...");
        Sys_Diagnostics::run();
        JsonDocument result_doc;
        result_doc["status"] = "completed";
        sendRpcResult(request, result_doc);
    }
    #endif
    else {
        sendRpcError(request, -32601, "Method not found");
    }
}

### Sys_WebServer.h & .cpp  
//本模块是系统的“前门”，负责处理所有来自网络的请求，是用户与设备交互的唯一通道。

#### - 职责清晰：严格分离HTTP API处理和WebSocket事件处理。

- 可扩展性：轻松添加新的API端点和WebSocket命令，而无需修改核心逻辑。

- 解耦：不直接执行业务逻辑，而是将收到的请求转化为命令，通过xCommandQueue发送给Task_Worker，实现与业务逻辑的完全解耦。

- 健壮性：处理了未找到的路由、Gzip内容协商、文件上传等常见Web服务场景。

- 资源管理：正确管理WebSocket客户端列表。

##### /**
 * @file Sys_WebServer.h
 * @brief 系统Web服务器模块的接口定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 该模块基于ESPAsyncWebServer库，创建并管理一个高效的异步Web服务器。
 * 它负责处理两类核心通信：
 * 1. HTTP RESTful API：用于前端发起的、请求-响应模式的操作（如获取设置）。
 * 2. WebSocket：用于实现服务器主动推送数据（如系统状态）和客户端的简单命令。
 *
 * 本模块遵循关注点分离原则，不执行任何耗时业务逻辑，而是将收到的请求
 * 转化为命令，通过命令队列发送给后台任务处理。
 */
#pragma once

#include <Arduino.h>
#include "ESPAsyncWebServer.h"
#include "ArduinoJson.h" // 需要JsonVariant

class Sys_WebServer {
public:
    /**
     * @brief 获取WebServer的单例实例。
     * @return Sys_WebServer* 指向唯一实例的指针。
     */
    static Sys_WebServer* getInstance();

    // 删除拷贝构造函数和赋值操作符，确保单例模式。
    Sys_WebServer(const Sys_WebServer&) = delete;
    Sys_WebServer& operator=(const Sys_WebServer&) = delete;

    /**
     * @brief 初始化并启动Web服务器和WebSocket服务。
     * @details 会设置好所有的HTTP路由和WebSocket事件回调。
     */
    void begin();

    /**
     * @brief 获取内部的WebSocket服务器实例指针。
     * @details 主要用于将其实例传递给`Task_WebSocketPusher`，以便该任务能推送数据。
     * @return AsyncWebSocket* 指向WebSocket服务器的指针。
     */
    AsyncWebSocket* getWebSocket();
    
    /**
     * @brief 清理所有已断开连接的WebSocket客户端。
     * @details `ESPAsyncWebServer`库要求定期调用此函数以释放资源。
     *          通常可以由`Task_SystemMonitor`周期性调用。
     */
    void cleanupClients();

private:
    // 私有构造函数，在其中初始化服务器和WebSocket对象。
    Sys_WebServer();

    // --- HTTP API 路由设置 ---
    /**
     * @brief 集中设置所有HTTP路由的私有辅助函数。
     */
    void setupHttpRoutes();

    // --- HTTP Route Handlers (静态方法) ---
    // 这些是处理具体HTTP请求的函数。
    
    /** @brief 处理获取系统设置的GET请求。*/
    static void handleGetSettings(AsyncWebServerRequest *request);
    /** @brief 处理保存系统设置的POST请求（带JSON Body）。*/
    static void handleSaveSettings(AsyncWebServerRequest *request, JsonVariant &json);
    /** @brief 处理WiFi扫描的GET请求。*/
    static void handleScanWiFi(AsyncWebServerRequest *request);
    /** @brief 处理文件上传。*/
    static void handleFileUpload(AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data, size_t len, bool final);
    /** @brief 处理所有未找到的路由 (404)。*/
    static void handleNotFound(AsyncWebServerRequest *request);

    // --- WebSocket 事件处理 ---
    /**
     * @brief WebSocket的核心事件回调函数。
     * @details 处理客户端的连接、断开、数据接收等所有WebSocket事件。
     */
    void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len);

    /** @brief 单例实例指针。*/
    static Sys_WebServer* _instance;
    
    /** @brief 异步Web服务器实例。*/
    AsyncWebServer _server;
    /** @brief 异步WebSocket实例，路径为 "/ws"。*/
    AsyncWebSocket _ws;
};


##### /**
 * @file Sys_WebServer.cpp
 * @brief 系统Web服务器模块的实现文件
 * @author [ANEAK]
 * @date [2025/7]
 * 
 * @details
 * 实现了所有HTTP路由和WebSocket事件处理的具体逻辑。
 * 它作为前端和后端业务逻辑之间的“翻译官”和“调度员”。
 */
#include "Sys_WebServer.h"
#include "types.h"
#include "Sys_Debug.h"
#include "Sys_Tasks.h"        // 需要访问 xCommandQueue 和 JsonRpcRequest 结构体
#include "Sys_Filesystem.h"   // 需要访问 LittleFS 和 FFat
#include "Sys_SettingsManager.h"

// 初始化静态单例指针
Sys_WebServer* Sys_WebServer::_instance = nullptr;

/**
 * @brief 获取WebServer的单例实例。
 */
Sys_WebServer* Sys_WebServer::getInstance() {
    if (_instance == nullptr) {
        _instance = new Sys_WebServer();
    }
    return _instance;
}

/**
 * @brief 构造函数，初始化服务器监听80端口，WebSocket服务路径为/ws。
 */
Sys_WebServer::Sys_WebServer() : _server(80), _ws("/ws") {}

/**
 * @brief 启动服务器。
 */
void Sys_WebServer::begin() {
    DEBUG_LOG("Initializing Web Server...");

    // 步骤1：将WebSocket事件回调函数绑定到WebSocket实例。
    // 使用C++ lambda表达式和[this]捕获，使得我们可以在类的成员函数中处理事件。
    _ws.onEvent([this](AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
        this->onWebSocketEvent(server, client, type, arg, data, len);
    });
    _server.addHandler(&_ws); // 将WebSocket处理器添加到Web服务器

    // 步骤2：设置所有HTTP路由
    setupHttpRoutes();

    // 步骤3：启动Web服务器
    _server.begin();
    ESP_LOGI("WebServer", "HTTP and WebSocket server started.");
}

/**
 * @brief 集中设置所有HTTP路由。
 */
void Sys_WebServer::setupHttpRoutes() {
    // --- 文件上传处理 ---
    // 所有POST到/upload的请求都会被这个处理器处理
    _server.on("/upload", HTTP_POST,
        // 上传成功后的响应回调
        [](AsyncWebServerRequest *request) {
            request->send(200, "text/plain", "Upload OK");
        },
        // 文件块数据处理回调
        handleFileUpload
    );

    // --- 静态文件服务 (Gzip内容协商优化) ---
    // 对所有静态资源请求进行拦截，优先提供.gz版本
    _server.on("/*", HTTP_GET, [](AsyncWebServerRequest *request){
        String path = request->url();
        if (path.endsWith("/")) path += "index.html";
        
        String contentType = "text/plain";
        if (path.endsWith(".html")) contentType = "text/html";
        else if (path.endsWith(".css")) contentType = "text/css";
        else if (path.endsWith(".js")) contentType = "application/javascript";
        
        if (LittleFS.exists(path + ".gz")) {
            AsyncWebServerResponse *response = request->beginResponse(LittleFS, path + ".gz", contentType);
            response->addHeader("Content-Encoding", "gzip");
            request->send(response);
        } else if (LittleFS.exists(path)) {
            request->send(LittleFS, path, contentType);
        } else {
            handleNotFound(request);
        }
    });

    // --- 媒体文件服务 ---
    // "/media" 路径的文件从FFat的根目录提供
    _server.serveStatic("/media", FFat, "/");

    // --- 404 Not Found 处理器 ---
    _server.onNotFound(handleNotFound);
}

AsyncWebSocket* Sys_WebServer::getWebSocket() {
    return &_ws;
}

void Sys_WebServer::cleanupClients() {
    _ws.cleanupClients();
}

// --- HTTP Route Handlers (静态方法实现) ---

void Sys_WebServer::handleFileUpload(AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data, size_t len, bool final) {
    static File uploadFile;
    // 安全地拼接路径，防止路径遍历攻击
    String path = "/media/" + filename;

    if (!index) { // 文件开始上传 (index=0)
        DEBUG_LOG("Upload Start: %s", path.c_str());
        if (FFat.exists(path)) { FFat.remove(path); }
        uploadFile = FFat.open(path, "w");
        if (!uploadFile) {
            ESP_LOGE("WebServer", "Failed to open file for writing: %s", path.c_str());
            return;
        }
    }

    if (len > 0 && uploadFile) {
        uploadFile.write(data, len); // 将接收到的数据块写入文件
    }

    if (final) { // 文件上传结束
        DEBUG_LOG("Upload End: %s, Total Size: %u", path.c_tr(), index + len);
        if (uploadFile) { uploadFile.close(); }
    }
}

void Sys_WebServer::handleNotFound(AsyncWebServerRequest *request) {
    // 根据请求的URL类型，返回不同的404响应
    if (request->url().startsWith("/api/")) {
        // API请求返回JSON错误
        request->send(404, "application/json", "{\"error\":\"API endpoint not found\"}");
    } else {
        // 普通页面请求返回HTML错误页
        request->send(404, "text/html", "<h1>404 Not Found</h1><p>The requested resource was not found on this server.</p>");
    }
}

// --- WebSocket 事件处理器 (JSON RPC 2.0) ---
void Sys_WebServer::onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
    switch (type) {
        case WS_EVT_CONNECT:
            ESP_LOGI("WebSocket", "Client #%u connected from %s", client->id(), client->remoteIP().toString().c_str());
            client->text("{\"jsonrpc\":\"2.0\",\"method\":\"server.welcome\",\"params\":{\"message\":\"Connection established!\"}}");
            break;

        case WS_EVT_DISCONNECT:
            ESP_LOGI("WebSocket", "Client #%u disconnected", client->id());
            break;

        case WS_EVT_DATA: {
            AwsFrameInfo *info = (AwsFrameInfo*)arg;
            if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
                
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, (const char*)data, len);

                if (error) {
                    client->text("{\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32700,\"message\":\"Parse error\"},\"id\":null}");
                    return;
                }

                // 验证JSON RPC 2.0格式
                if (strcmp(doc["jsonrpc"], "2.0") != 0 || doc["method"].isNull()) {
                    client->text("{\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32600,\"message\":\"Invalid Request\"},\"id\":null}");
                    return;
                }

                // 封装为内部命令结构体
                JsonRpcRequest rpcRequest;
                rpcRequest.id = doc["id"] | 0; // 如果id不存在，默认为0
                rpcRequest.client_id = client->id();
                
                strncpy(rpcRequest.method, doc["method"], sizeof(rpcRequest.method) - 1);
                
                if (!doc["params"].isNull()) {
                    serializeJson(doc["params"], rpcRequest.params, sizeof(rpcRequest.params));
                }

                // 发送到命令队列
                if (xQueueSend(xCommandQueue, &rpcRequest, pdMS_TO_TICKS(10)) != pdPASS) {
                    ESP_LOGE("WebServer", "Command queue full, dropping RPC request.");
                    client->text("{\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32000,\"message\":\"Server busy, command queue full\"},\"id\":rpcRequest.id}");
                }
            }
            break;
        }
        case WS_EVT_PONG:
        case WS_EVT_ERROR:
            break;
    }
}


### Sys_FilesManager.h & .cpp 
//本模块负责文件系统管理器的挂载。


#### - 在公共接口中增加对文件系统是否已挂载的检查。
- 信息获取：提供获取文件系统大小和使用情况的公共接口，供其它模块使用。

##### /**
 * @file Sys_Filesystem.h
 * @brief 系统文件系统管理器的接口定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 该模块负责初始化和管理设备上的所有文件系统，包括用于Web UI的LittleFS
 * 和用于大文件存储的FFat。它封装了文件系统的挂载逻辑，并向上层
 * 模块提供对已挂载文件系统的访问。
 */
#pragma once

#include <Arduino.h>
#include "FS.h"
#include "LittleFS.h"
#include "FFat.h"

/**
 * @class Sys_Filesystem
 * @brief 文件系统管理器，负责挂载和提供对LittleFS和FFat的访问。
 */
class Sys_Filesystem {
public:
    /**
     * @brief 获取文件系统管理器的单例实例。
     * @note  必须在系统进入多任务调度前（如在setup()中）完成首次调用。
     * @return Sys_Filesystem* 指向唯一实例的指针。
     */
    static Sys_Filesystem* getInstance();
    // 删除拷贝构造函数和赋值操作符。
    Sys_Filesystem(const Sys_Filesystem&) = delete;
    Sys_Filesystem& operator=(const Sys_Filesystem&) = delete;

    /**
     * @brief 在系统启动时调用，挂载所有已定义的文件系统。
     * @details 采用“失败时格式化”策略，只在首次启动或文件系统损坏时进行格式化。
     * @return bool `true` 如果所有文件系统都成功挂载，否则为 `false`。
     */
    bool begin();

    // --- 文件系统状态查询接口 ---
    
    /** @brief 检查LittleFS是否已成功挂载。*/
    bool isLittleFSMounted() const { return _littlefs_mounted; }
    /** @brief 检查FFat是否已成功挂载。*/
    bool isFFatMounted() const { return _ffat_mounted; }

    // --- 文件系统信息获取接口 ---
    // 这些接口供诊断或系统状态监控使用。

    /** @brief 获取LittleFS的总字节数。*/
    uint64_t getLittleFSTotalBytes();
    /** @brief 获取LittleFS已使用的字节数。*/
    uint64_t getLittleFSUsedBytes();
    /** @brief 获取FFat的总字节数。*/
    uint64_t getFFatTotalBytes();
    /** @brief 获取FFat已使用的字节数。*/
    uint64_t getFFatUsedBytes();

private:
    // 私有构造函数，由`getInstance()`调用。
    Sys_Filesystem() = default;

    /**
     * @brief 一个通用的、挂载单个文件系统的私有辅助模板函数。
     * @details C++模板函数的定义必须放在头文件中，以便编译器在调用点实例化。
     * @tparam FSType 文件系统类的具体类型 (e.g., LittleFSFS, FFatFS)。
     * @param fs 文件系统对象的引用 (如 LittleFS, FFat)。
     * @param partition_label 分区表中的标签名。
     * @param mount_point 挂载点路径。
     * @return bool 是否成功挂载。
     */
    template<typename FSType>
    bool mountFs(FSType& fs, const char* partition_label, const char* mount_point) {
        ESP_LOGI("FS", "Mounting '%s' partition to '%s'...", partition_label, mount_point);
        
        if (fs.begin(false, mount_point, 10, partition_label)) {
            ESP_LOGI("FS", "'%s' mounted successfully.", partition_label);
            return true;
        }

        ESP_LOGE("FS", "'%s' mount failed! Attempting to format...", partition_label);
        if (fs.format()) {
            ESP_LOGI("FS", "'%s' partition formatted successfully. Remounting...", partition_label);
            if (fs.begin(false, mount_point, 10, partition_label)) {
                ESP_LOGI("FS", "'%s' remounted successfully after format.", partition_label);
                return true;
            } else {
                ESP_LOGE("FS", "FATAL: '%s' remount failed after format!", partition_label);
                return false;
            }
        } else {
            ESP_LOGE("FS", "FATAL: Formatting '%s' partition failed!", partition_label);
            return false;
        }
    }
    
    /** @brief 单例实例指针。*/
    static Sys_Filesystem* _instance;

    /** @brief 标志位，记录LittleFS的挂载状态。*/
    bool _littlefs_mounted = false;
    /** @brief 标志位，记录FFat的挂载状态。*/
    bool _ffat_mounted = false;
};


##### /**
 * @file Sys_Filesystem.cpp
 * @brief 系统文件系统管理器的实现文件
 * @author [ANEAK]
 * @date [2025/7]
 * 
 * @details
 * 实现了LittleFS和FFat的挂载逻辑。
 * 采用了“失败时格式化”的健壮策略。
 */
#include "Sys_Filesystem.h"
#include "Sys_Debug.h"

// 初始化静态单例指针
Sys_Filesystem* Sys_Filesystem::_instance = nullptr;


/**
 * @brief 获取文件系统管理器的单例实例。
 */
Sys_Filesystem* Sys_Filesystem::getInstance() {
    if (_instance == nullptr) {
        _instance = new Sys_Filesystem();
    }
    return _instance;
}

/**
 * @brief 初始化并挂载所有文件系统。
 */
bool Sys_Filesystem::begin() {
    DEBUG_LOG("Initializing filesystems...");

    _littlefs_mounted = mountFs(LittleFS, "littlefs", "/");
    _ffat_mounted = mountFs(FFat, "ffat", "/media");

    return _littlefs_mounted && _ffat_mounted;
}

/**
 * @brief 获取LittleFS的总空间。
 */
uint64_t Sys_Filesystem::getLittleFSTotalBytes() {
    return _littlefs_mounted ? LittleFS.totalBytes() : 0;
}

/**
 * @brief 获取LittleFS已用空间。
 */
uint64_t Sys_Filesystem::getLittleFSUsedBytes() {
    return _littlefs_mounted ? LittleFS.usedBytes() : 0;
}

/**
 * @brief 获取FFat的总空间。
 */
uint64_t Sys_Filesystem::getFFatTotalBytes() {
    return _ffat_mounted ? FFat.totalBytes() : 0;
}

/**
 * @brief 获取FFat已用空间。
 */
uint64_t Sys_Filesystem::getFFatUsedBytes() {
    return _ffat_mounted ? FFat.usedBytes() : 0;
}

// The original mountFs member function is no longer needed.


### Sys_WiFiManager.h & .cpp 
//封装WIFI连接、采用事件驱动模型。

#### - 采用事件驱动模型：完全依赖WiFi.onEvent()来处理连接、断开、获取IP等事件。

- 简化状态管理：内部维护一个清晰的枚举WiFiState，使得模块的当前状态一目了然。

- 彻底解耦配置：不再自己持有_currentSettings，而是每次需要时都从Sys_SettingsManager获取最新的权威配置，遵循了“单一事实来源”原则。

- 职责纯粹：Sys_WiFiManager只负责应用配置和维持连接。

##### /**
 * @file Sys_WiFiManager.h
 * @brief 一个事件驱动的、状态机清晰的、健壮的WiFi管理器。
 * @author [ANEAK]
 * @date [2025/7]
 * 
 * @details
 * 该模块负责根据系统配置来维持WiFi连接，并向外提供清晰的状态。
 * 它不处理业务逻辑（如扫描、保存），只负责应用配置。
 * 优化点：
 * 1. 引入互斥锁，确保所有WiFi操作的原子性，防止竞态条件。
 * 2. 引入智能重连机制，对永久性失败（如密码错误）进行有限次重试，避免无效功耗。
 * 3. 状态转换逻辑全部集中在事件回调中，使状态机模型更纯粹。
 */
#pragma once

#include "WiFi.h"
#include "Sys_SettingsManager.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "Sys_LockGuard.h" // 引入RAII锁

// 定义清晰的WiFi状态，供外部模块查询
enum class WiFiState {
    WIFI_STATE_DISABLED, // WiFi功能被禁用
    DISCONNECTED,      // STA模式下，已断开连接，正在等待重连超时
    CONNECTING,        // STA模式下，正在尝试连接
    CONNECTED_STA,     // STA模式下，已成功连接并获取IP
    HOSTING_AP,        // AP模式下，正在广播热点
    HOSTING_AP_STA,    // AP+STA模式，且STA已连接
    FAILED_PERMANENTLY // [优化] STA连接因配置错误等永久性原因失败，已停止重试
};

class Sys_WiFiManager {
public:
    // 获取单例实例
    static Sys_WiFiManager* getInstance();
    // 禁止拷贝和赋值
    Sys_WiFiManager(const Sys_WiFiManager&) = delete;
    Sys_WiFiManager& operator=(const Sys_WiFiManager&) = delete;

    /**
     * @brief 在系统启动时调用，注册WiFi事件回调并创建同步机制。
     */
    void begin();

    /**
     * @brief 由 Task_SystemMonitor 周期性调用，用于处理非事件驱动的逻辑（如超时重连）。
     */
    void update();
    
    /**
     * @brief 应用最新的系统设置。这是控制WiFi行为的核心入口。
     * @details 这是一个线程安全的操作，它会根据新设置触发相应的WiFi动作。
     */
    void applySettings();

    /**
     * @brief 获取当前WiFi模块的聚合状态。
     * @return WiFiState 当前状态。
     */
    WiFiState getCurrentState();
    
    /**
     * @brief 获取当前设备的IP地址。
     * @return String IP地址字符串，如果未连接则为 "0.0.0.0"。
     */
    String getIPAddress();

private:
    // 私有构造函数
    Sys_WiFiManager();
    
    // WiFi事件的静态回调函数
    static void WiFiEvent(WiFiEvent_t event, arduino_event_info_t info);

    // 内部启动STA和AP的辅助函数
    void startSTA(const SystemSettings& settings);
    void startAP(const SystemSettings& settings);
    void stopSTA();
    void stopAP();

    // 单例实例指针
    static Sys_WiFiManager* _instance;
    
    // 内部状态机
    volatile WiFiState _currentState = WiFiState::WIFI_STATE_DISABLED; // [优化] 使用 volatile 确保多线程可见性
    
    // [优化] 引入互斥锁，保护所有临界区
    SemaphoreHandle_t _mutex = NULL;
    
    // 非阻塞重连逻辑所需的计时器和计数器
    unsigned long _last_reconnect_attempt_ms = 0;
    uint8_t _sta_retry_count = 0; // [优化] STA重试计数器
};


##### /**
 * @file Sys_WiFiManager.cpp
 * @brief WiFi管理器的健壮性实现
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 */
#include "Sys_WiFiManager.h"
#include "Sys_Debug.h"

// [优化] 定义重连相关的常量
static constexpr const uint32_t RECONNECT_INTERVAL_MS = 10000; // 10秒重连间隔
static constexpr const uint8_t MAX_STA_RETRIES = 3;            // 对于永久性错误，最多重试3次

Sys_WiFiManager* Sys_WiFiManager::_instance = nullptr;

Sys_WiFiManager* Sys_WiFiManager::getInstance() {
    if (_instance == nullptr) {
        _instance = new Sys_WiFiManager();
    }
    return _instance;
}

Sys_WiFiManager::Sys_WiFiManager() {
    // [优化] 在构造函数中创建互斥锁
    _mutex = xSemaphoreCreateMutex();
    if (_mutex == NULL) {
        ESP_LOGE("WiFiMan", "FATAL: Failed to create mutex!");
    }
}

void Sys_WiFiManager::begin() {
    // 关键：让静态回调能找到实例。这必须在注册回调之前完成。
    _instance = this; 
    WiFi.onEvent(WiFiEvent); // 注册统一的事件回调
    
    // 首次启动时，应用一次当前配置
    applySettings();
}

void Sys_WiFiManager::applySettings() {
    Sys_LockGuard lock(_mutex); // [优化] 保护整个应用过程，确保原子性

    DEBUG_LOG("Applying new WiFi settings...");
    const auto& settings = Sys_SettingsManager::getInstance()->getSettings();
    
    // 重置永久失败状态和重试计数器，因为我们有了新的配置
    if (_currentState == WiFiState::FAILED_PERMANENTLY) {
        _currentState = WiFiState::WIFI_STATE_DISABLED;
    }
    _sta_retry_count = 0;

    // 设置WiFi模式。这是启动STA/AP的前提。
    WiFi.mode((wifi_mode_t)settings.wifi_mode);

    // 根据新的模式，决定启动或停止STA/AP
    bool should_have_sta = (settings.wifi_mode == SystemSettings::WIFI_MODE_STA || settings.wifi_mode == SystemSettings::WIFI_MODE_AP_STA);
    bool should_have_ap  = (settings.wifi_mode == SystemSettings::WIFI_MODE_AP  || settings.wifi_mode == SystemSettings::WIFI_MODE_AP_STA);
    
    // 触发动作，但不直接改变状态。状态由事件驱动。
    if (should_have_sta) {
        startSTA(settings);
    } else {
        stopSTA();
    }

    if (should_have_ap) {
        startAP(settings);
    } else {
        stopAP();
    }
    
    if (!should_have_sta && !should_have_ap) {
        // 这是唯一一个可以直接设置的状态，因为它不会触发事件
        _currentState = WiFiState::WIFI_STATE_DISABLED;
        ESP_LOGI("WiFiMan", "WiFi is now disabled.");
    }
}

void Sys_WiFiManager::update() {
    // update()只负责一件事情：处理非永久性断开后的超时重连
    if (getCurrentState() == WiFiState::DISCONNECTED) {
        if (millis() - _last_reconnect_attempt_ms > RECONNECT_INTERVAL_MS) {
            Sys_LockGuard lock(_mutex); // [优化] 保护重连动作
            ESP_LOGI("WiFiMan", "Reconnect timeout. Attempting to connect again...");
            const auto& settings = Sys_SettingsManager::getInstance()->getSettings();
            WiFi.begin(settings.wifi_ssid, settings.wifi_password);
            // 不在此处改变状态，等待WIFI_STA_START事件
        }
    }
}

WiFiState Sys_WiFiManager::getCurrentState() {
    // 对于读取volatile变量，虽然是原子操作，但加锁可以保证获取到的是一个更一致的快照
    Sys_LockGuard lock(_mutex);
    return _currentState;
}

String Sys_WiFiManager::getIPAddress() {
    Sys_LockGuard lock(_mutex);
    if (_currentState == WiFiState::CONNECTED_STA || _currentState == WiFiState::HOSTING_AP_STA) {
        return WiFi.localIP().toString();
    }
    if (_currentState == WiFiState::HOSTING_AP) {
        return WiFi.softAPIP().toString();
    }
    return "0.0.0.0";
}

// --- Private Helper Methods (仅由 applySettings 调用，已在锁的保护下) ---

void Sys_WiFiManager::startSTA(const SystemSettings& settings) {
    if (strlen(settings.wifi_ssid) > 0) {
        ESP_LOGI("WiFiMan", "Triggering STA mode for SSID: %s", settings.wifi_ssid);
        if (settings.wifi_static_ip_enabled) {
            IPAddress staticIP, gateway, subnet;
            if (staticIP.fromString(settings.wifi_static_ip) && gateway.fromString(settings.wifi_gateway) && subnet.fromString(settings.wifi_subnet)) {
                WiFi.config(staticIP, gateway, subnet);
                 ESP_LOGI("WiFiMan", "Using static IP configuration.");
            } else {
                ESP_LOGW("WiFiMan", "Invalid static IP configuration, falling back to DHCP.");
            }
        }
        WiFi.begin(settings.wifi_ssid, settings.wifi_password);
    } else {
        ESP_LOGW("WiFiMan", "STA mode enabled, but no SSID configured.");
        stopSTA();
    }
}

void Sys_WiFiManager::startAP(const SystemSettings& settings) {
    const char* ap_ssid = "ESP32S3-Device"; // Can be read from settings in the future
    ESP_LOGI("WiFiMan", "Triggering AP mode with SSID: %s", ap_ssid);
    WiFi.softAP(ap_ssid);
}

void Sys_WiFiManager::stopSTA() {
    if (WiFi.isConnected()) {
        WiFi.disconnect(true);
    }
}

void Sys_WiFiManager::stopAP() {
    WiFi.softAPdisconnect(true);
}

// --- Static Event Handler ---
// 这是整个模块的核心驱动力，所有状态转换都在这里发生
void Sys_WiFiManager::WiFiEvent(WiFiEvent_t event, arduino_event_info_t info) {
    if (!_instance) return;

    // 保护事件处理的全过程，防止与 applySettings 等发生冲突
    Sys_LockGuard lock(_instance->_mutex); 

    DEBUG_LOG("WiFi Event received: %d", event);

    switch (event) {
        case ARDUINO_EVENT_WIFI_AP_START:
            ESP_LOGI("WiFiMan", "AP Mode Started. IP: %s", WiFi.softAPIP().toString().c_str());
            _instance->_currentState = WiFi.isConnected() ? WiFiState::HOSTING_AP_STA : WiFiState::HOSTING_AP;
            break;

        case ARDUINO_EVENT_WIFI_AP_STOP:
            ESP_LOGI("WiFiMan", "AP Mode Stopped.");
            // 如果STA也未连接，则为完全禁用
            if (!WiFi.isConnected()) {
                _instance->_currentState = WiFiState::WIFI_STATE_DISABLED;
            } else {
                 _instance->_currentState = WiFiState::CONNECTED_STA;
            }
            break;

        case ARDUINO_EVENT_WIFI_STA_START:
            ESP_LOGI("WiFiMan", "STA Mode Started. Connecting...");
            _instance->_currentState = WiFiState::CONNECTING;
            _instance->_last_reconnect_attempt_ms = millis();
            break;
            
        case ARDUINO_EVENT_WIFI_STA_CONNECTED:
            ESP_LOGI("WiFiMan", "STA Connected to SSID: %s. Waiting for IP...", (char*)info.wifi_sta_connected.ssid);
            // 状态仍然是CONNECTING，直到获取IP
            break;

        case ARDUINO_EVENT_WIFI_STA_GOT_IP:
            ESP_LOGI("WiFiMan", "STA Got IP: %s", IPAddress(info.got_ip.ip_info.ip.addr).toString().c_str());
            _instance->_sta_retry_count = 0; // 连接成功，重置重试计数器
            _instance->_currentState = WiFi.softAPgetStationNum() > 0 ? WiFiState::HOSTING_AP_STA : WiFiState::CONNECTED_STA;
            break;

        case ARDUINO_EVENT_WIFI_STA_DISCONNECTED: {
            wifi_err_reason_t reason = (wifi_err_reason_t)info.wifi_sta_disconnected.reason;
            ESP_LOGW("WiFiMan", "STA Disconnected. Reason: %d (%s)", reason, WiFi.disconnectReasonName(reason));

            // [优化] 智能重连逻辑
            // 检查是否是“永久性”错误
            if (reason == WIFI_REASON_NO_AP_FOUND || reason == WIFI_REASON_AUTH_EXPIRE || reason == WIFI_REASON_AUTH_FAIL) {
                _instance->_sta_retry_count++;
                ESP_LOGW("WiFiMan", "Permanent-like failure. Retry attempt %d/%d.", _instance->_sta_retry_count, MAX_STA_RETRIES);
                if (_instance->_sta_retry_count >= MAX_STA_RETRIES) {
                    ESP_LOGE("WiFiMan", "Max retries reached. Entering permanent failure state.");
                    _instance->_currentState = WiFiState::FAILED_PERMANENTLY;
                    // 在这里停止，不再尝试重连
                    break; 
                }
            }
            // 对于其他临时性断开或未达到重试上限的永久性错误，进入常规重连流程
            _instance->_currentState = WiFiState::DISCONNECTED;
            _instance->_last_reconnect_attempt_ms = millis(); 
            break;
        }
        
        default:
            break;
    }
}


### Sys_BlueToothManager.h & .cpp 
//本模块负责管理蓝牙的生命周期和基本配置。


#### - 清晰的状态管理：内部维护一个明确的状态机，便于理解和扩展。

- 配置驱动：模块的行为完全由 Sys_SettingsManager 中的配置决定。

- 非阻塞：所有操作都是非阻塞的，启动和停止蓝牙不会卡住系统。

- 共存友好：预留了与其他模块（特别是WiFi）协调共存的接口。

- 关注点分离：只负责蓝牙核心逻辑的管理，不涉及Web通信或NVS读写。

##### /**
 * @file Sys_BlueToothManager.h
 * @brief 系统蓝牙(BLE)管理器的接口定义 (基于NimBLE)
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 *  该模块基于NimBLE库，负责管理BLE协议栈的生命周期、广播行为和连接状态。
 *  它的行为完全由`Sys_SettingsManager`中的配置驱动，并将复杂的BLE底层API
 *  封装在内部，对外提供简洁的控制接口和清晰的状态机。
 *  ESP32-S3仅支持BLE，不支持经典蓝牙。
 */
#pragma once

#include <Arduino.h>
#include "NimBLEDevice.h"
#include "Sys_SettingsManager.h" // 需要读取蓝牙配置

/**
 * @enum BlueToothState
 * @brief 定义了BLE模块的清晰、有限的运行状态。
 */
enum class BlueToothState {
    UNINITIALIZED,  // 未初始化，或初始化失败
    BT_DISABLED,    // 已初始化但被用户配置禁用 (添加前缀以避免宏冲突)
    ADVERTISING,    // 正在广播
    CONNECTED       // 已有客户端连接
};

/**
 * @class Sys_BlueToothManager
 * @brief 系统BLE管理器，负责BLE的广播、连接和配置应用。
 */
class Sys_BlueToothManager : public NimBLEServerCallbacks {
public:
    /**
     * @brief 获取蓝牙管理器的单例实例。
     * @return Sys_BlueToothManager* 指向唯一实例的指针。
     */
    static Sys_BlueToothManager* getInstance();
    // 删除拷贝构造函数和赋值操作符，确保单例模式。
    Sys_BlueToothManager(const Sys_BlueToothManager&) = delete;
    Sys_BlueToothManager& operator=(const Sys_BlueToothManager&) = delete;

    /**
     * @brief 在系统启动时调用，初始化NimBLE协议栈。
     */
    void begin();

    /**
     * @brief 由 Task_SystemMonitor 周期性调用。
     * @details 目前为空，为未来扩展预留。
     */
    void update();

    /**
     * @brief 应用最新的系统设置。这是控制BLE行为的核心入口。
     * @details 当用户在Web界面保存配置后，由Task_Worker调用此方法。
     *          它会比较新旧设置，并执行必要的启动广播、停止广播或重命名操作。
     */
    void applySettings();

    /**
     * @brief 获取当前BLE模块的状态。
     * @return BlueToothState 当前状态。
     */
    BlueToothState getCurrentState() const;

    // --- NimBLEServerCallbacks 回调函数 ---
    /** @brief 处理客户端连接事件。*/
    void onConnect(NimBLEServer* pServer) override;
    /** @brief 处理客户端断开连接事件。*/
    void onDisconnect(NimBLEServer* pServer) override;

private:
    // 私有构造函数，由`getInstance()`调用。
    Sys_BlueToothManager() = default;

    // --- 内部状态转换的核心函数 ---
    /** @brief 启动BLE广播。*/
    bool startAdvertising();
    /** @brief 停止BLE广播。*/
    bool stopAdvertising();
    /** @brief 设置BLE设备名称。*/
    void setDeviceName(const char* name);

    /** @brief 单例实例指针。*/
    static Sys_BlueToothManager* _instance;
    /** @brief 当前BLE模块的状态机状态。*/
    volatile BlueToothState _currentState = BlueToothState::UNINITIALIZED;
    /** @brief 内存中缓存的当前设备名称，用于比较配置是否变更。*/
    char _currentDeviceName[33] = "";

    /** @brief 指向NimBLE服务器实例的指针。*/
    NimBLEServer* _pServer = nullptr;
    /** @brief 指向NimBLE广播实例的指针。*/
    NimBLEAdvertising* _pAdvertising = nullptr;
};

##### /**
 * @file Sys_BlueToothManager.cpp
 * @brief 系统蓝牙(BLE)管理器的实现文件 (基于NimBLE)
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 *  实现了基于NimBLE库的BLE协议栈初始化、广播管理和连接回调处理。
 *  ESP32-S3仅支持BLE，此模块专为此设计。
 */
#include "Sys_BlueToothManager.h"
#include "Sys_Debug.h"

// 初始化静态单例指针
Sys_BlueToothManager* Sys_BlueToothManager::_instance = nullptr;

/**
 * @brief 获取蓝牙管理器的单例实例。
 */
Sys_BlueToothManager* Sys_BlueToothManager::getInstance() {
    if (_instance == nullptr) {
        _instance = new Sys_BlueToothManager();
    }
    return _instance;
}

/**
 * @brief 模块初始化。
 */
void Sys_BlueToothManager::begin() {
    _instance = this; // 将this指针赋给静态实例，以便回调函数能访问到非静态成员
    
    DEBUG_LOG("Initializing NimBLE stack...");
    
    // 步骤1: 初始化NimBLE库
    // true表示初始化ESP控制器，false表示不初始化（如果已由其他组件初始化）
    NimBLEDevice::init(""); // 设备名称将在applySettings中设置
    
    // 步骤2: 创建一个新的BLE服务器
    _pServer = NimBLEDevice::createServer();
    if (!_pServer) {
        ESP_LOGE("BTMan", "Failed to create BLE Server!");
        _currentState = BlueToothState::UNINITIALIZED;
        return;
    }
    
    // 步骤3: 设置服务器回调
    // this指针指向的对象（即Sys_BlueToothManager实例）将处理连接和断开事件
    _pServer->setCallbacks(this);

    // 步骤4: 获取广播实例
    _pAdvertising = NimBLEDevice::getAdvertising();
    if (!_pAdvertising) {
        ESP_LOGE("BTMan", "Failed to get BLE Advertising instance!");
        _currentState = BlueToothState::UNINITIALIZED;
        return;
    }
    
    // [示例] 添加一个设备信息服务 (Device Information Service)
    // 这有助于BLE扫描器识别设备类型
    _pAdvertising->addServiceUUID(NimBLEUUID("180A"));

    _currentState = BlueToothState::BT_DISABLED; // 初始状态为已初始化但禁用

    // 步骤5: 初始化完成后，立即应用一次当前的系统配置
    applySettings();
}

/**
 * @brief 周期性更新函数。
 */
void Sys_BlueToothManager::update() {
    // NimBLE是事件驱动的，此函数暂时为空。
}

/**
 * @brief 应用最新的系统设置。
 */
void Sys_BlueToothManager::applySettings() {
    DEBUG_LOG("Applying new BLE settings...");
    const auto& settings = Sys_SettingsManager::getInstance()->getSettings();
    
    bool shouldBeEnabled = settings.bluetooth_enabled;
    bool isAdvertising = (_currentState == BlueToothState::ADVERTISING);

    // 更新设备名称
    setDeviceName(settings.bluetooth_name);

    if (shouldBeEnabled && !isAdvertising) {
        startAdvertising();
    } else if (!shouldBeEnabled && isAdvertising) {
        stopAdvertising();
    }
}

/**
 * @brief 获取当前状态。
 */
BlueToothState Sys_BlueToothManager::getCurrentState() const {
    return _currentState;
}

// --- NimBLEServerCallbacks 回调函数 ---

/**
 * @brief 处理客户端连接事件。
 */
void Sys_BlueToothManager::onConnect(NimBLEServer* pServer) {
    ESP_LOGI("BTMan", "BLE Client Connected.");
    _currentState = BlueToothState::CONNECTED;
}

/**
 * @brief 处理客户端断开连接事件。
 */
void Sys_BlueToothManager::onDisconnect(NimBLEServer* pServer) {
    ESP_LOGI("BTMan", "BLE Client Disconnected.");
    // 断开连接后，根据配置决定是返回禁用状态还是重新开始广播
    const auto& settings = Sys_SettingsManager::getInstance()->getSettings();
    if (settings.bluetooth_enabled) {
        // 延迟一小段时间后重新广播，给客户端一些时间来处理断开
        vTaskDelay(pdMS_TO_TICKS(100));
        startAdvertising();
    } else {
        _currentState = BlueToothState::BT_DISABLED;
    }
}

// --- 私有辅助方法 (Private Methods) ---

/**
 * @brief 启动BLE广播。
 */
bool Sys_BlueToothManager::startAdvertising() {
    if (_currentState == BlueToothState::ADVERTISING || !_pAdvertising) {
        return true;
    }
    ESP_LOGI("BTMan", "Starting BLE advertising...");
    if (_pAdvertising->start()) {
        _currentState = BlueToothState::ADVERTISING;
        return true;
    } else {
        ESP_LOGE("BTMan", "Failed to start advertising.");
        return false;
    }
}

/**
 * @brief 停止BLE广播。
 */
bool Sys_BlueToothManager::stopAdvertising() {
    if (_currentState != BlueToothState::ADVERTISING || !_pAdvertising) {
        return true;
    }
    ESP_LOGI("BTMan", "Stopping BLE advertising...");
    if (_pAdvertising->stop()) {
        _currentState = BlueToothState::BT_DISABLED;
        return true;
    } else {
        ESP_LOGE("BTMan", "Failed to stop advertising.");
        return false;
    }
}

/**
 * @brief 设置BLE设备名称。
 */
void Sys_BlueToothManager::setDeviceName(const char* name) {
    if (!name || strlen(name) == 0 || strcmp(_currentDeviceName, name) == 0) {
        return; // 如果名称为空或未改变，则不执行任何操作
    }

    ESP_LOGI("BTMan", "Setting BLE device name to: '%s'", name);
    // 更新NimBLE设备名称
    NimBLEDevice::setDeviceName(name);
    
    // 如果正在广播，需要重启广播以应用新名称
    if (_currentState == BlueToothState::ADVERTISING) {
        _pAdvertising->stop();
        _pAdvertising->start();
    }
    
    // 更新内部缓存
    strncpy(_currentDeviceName, name, sizeof(_currentDeviceName) - 1);
    _currentDeviceName[sizeof(_currentDeviceName) - 1] = '\0';
}

### Sys_FlashLogger.h & .cpp 
//封装Flash持续写入数据友好存储机制 。日志记录基础。

#### - 在PSRAM中维护一个环形缓冲区减少频繁擦写，保护Flash寿命。

- 产生和存储日志使关键信息持久化。

- 在文件系统初始化之后调用，在重启前确保日志保存。

##### /**
 * @file Sys_FlashLogger.h
 * @brief Flash友好型日志记录器的接口定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 该模块旨在解决直接、频繁地向Flash写入小数据块而导致的性能和寿命问题。
 * 它实现了一个基于PSRAM环形缓冲区的二级日志系统：
 * 1. 日志首先被快速、非阻塞地写入PSRAM中的`Ringbuf`。
 * 2. 一个低优先级的后台任务负责在满足条件（缓冲区满或超时）时，
 *    将缓冲区中的数据一次性、批量地写入Flash上的日志文件。
 *
 * 这种机制极大地减少了Flash的擦写次数，是构建可靠、长寿命产品的关键。
 *
 * @note 本模块所有公共方法均设计为线程安全。
 */
#pragma once

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/ringbuf.h"   // 使用FreeRTOS高效的环形缓冲区
#include "freertos/semphr.h"    // 引入信号量头文件，用于线程同步
#include "Sys_LockGuard.h"      // 引入RAII锁

/**
 * @class Sys_FlashLogger
 * @brief 一个对Flash友好的、基于PSRAM环形缓冲区的日志记录器。
 */
class Sys_FlashLogger {
public:
    /**
     * @brief 获取日志记录器的单例实例。
     * @note  必须在系统进入多任务调度前（如在setup()中）完成首次调用。
     * @return Sys_FlashLogger* 指向唯一实例的指针。
     */
    static Sys_FlashLogger* getInstance();
    // 删除拷贝构造函数和赋值操作符。
    Sys_FlashLogger(const Sys_FlashLogger&) = delete;
    Sys_FlashLogger& operator=(const Sys_FlashLogger&) = delete;

    /**
     * @brief 初始化日志记录器，创建PSRAM缓冲区和后台写入任务。
     * @details 必须在文件系统模块初始化之后调用。
     * @param log_filepath 日志文件的完整路径 (例如, "/media/system.log")。
     * @param buffer_size PSRAM中环形缓冲区的大小 (字节)。建议为4KB的倍数。
     * @param flush_interval_ms 后台任务定时强制刷写缓冲区的间隔 (毫秒)。
     * @return bool `true` 表示初始化成功, `false` 表示失败。
     */
    bool begin(const char* log_filepath, size_t buffer_size = 8192, uint32_t flush_interval_ms = 60000);

    /**
     * @brief 记录一条格式化的日志。
     * @details 这是一个快速的、线程安全的操作，它只将数据写入PSRAM缓冲区，然后立即返回。
     * @param format `printf`风格的格式化字符串。
     * @param ... 可变参数。
     */
    void log(const char* format, ...);

    /**
     * @brief 强制将缓冲区中所有待处理的日志立即写入Flash。
     * @details 这是一个线程安全的异步请求。它会通知后台任务尽快执行刷写操作。
     *          用于在系统重启或发生严重错误前，确保所有日志都被保存。
     */
    void flush();
    
    /**
     * @brief 线程安全地删除当前的日志文件。
     * @details 可用于实现日志的轮转(log rotation)或手动清理。
     *          此操作会等待任何正在进行的写操作完成后再执行。
     */
    void clearLogFile();

private:
    // 私有构造函数
    Sys_FlashLogger();

    /**
     * @brief 后台任务的核心循环函数，负责将缓冲区数据写入文件。
     */
    static void flushTask(void* parameter);
    
    /**
     * @brief 实际执行从缓冲区读取并写入文件操作的函数。
     * @note  这个方法内部实现了对文件I/O的互斥访问。
     */
    void writeBufferToFile();

    /** @brief 单例实例指针。*/
    static Sys_FlashLogger* _instance;
    
    /** @brief FreeRTOS环形缓冲区的句柄。*/
    RingbufHandle_t _ring_buffer_handle = NULL;
    /** @brief 后台刷写任务的句柄。*/
    TaskHandle_t _flush_task_handle = NULL;
    /** @brief 用于手动触发立即刷写的二进制信号量。*/
    SemaphoreHandle_t _flush_semaphore = NULL;
    /** 
     * @brief 用于保护文件I/O操作的互斥锁 (Mutex)。
     * @details 这是确保多任务环境下文件系统访问安全的关键。
     *          任何对日志文件的`open`, `write`, `remove`等操作都必须先获取此锁。
     */
    SemaphoreHandle_t _file_mutex = NULL;
    
    /** @brief 日志文件的路径。*/
    String _log_filepath;
    /** @brief 定时刷写的间隔。*/
    uint32_t _flush_interval_ms;
};


##### /**
 * @file Sys_FlashLogger.cpp
 * @brief Flash友好型日志记录器的实现文件
 * @author [ANEAK]
 * @date [2025/7]
 * 
 * @details
 * 实现了日志的缓冲、后台任务的创建和文件写入逻辑。
 * 它利用了FreeRTOS的Ringbuf和两种同步原语，实现了高效、线程安全的日志处理：
 * 1. **`_flush_semaphore` (二元信号量):** 用于从任何任务触发一次刷写操作。
 * 2. **`_file_mutex` (互斥信号量):** 用于保护对日志文件的实际I/O，防止并发访问导致的文件系统损坏。
 */
#include "Sys_FlashLogger.h"
#include "Sys_Debug.h"
#include "Sys_Filesystem.h" // 需要文件系统来操作文件
#include <cstdarg>

// 初始化静态单例指针
Sys_FlashLogger* Sys_FlashLogger::_instance = nullptr;

Sys_FlashLogger::Sys_FlashLogger() {}

/**
 * @brief 获取日志记录器的单例实例。
 */
Sys_FlashLogger* Sys_FlashLogger::getInstance() {
    if (_instance == nullptr) {
        _instance = new Sys_FlashLogger();
    }
    return _instance;
}

/**
 * @brief 初始化日志记录器。
 */
bool Sys_FlashLogger::begin(const char* log_filepath, size_t buffer_size, uint32_t flush_interval_ms) {
    if (_ring_buffer_handle) {
        ESP_LOGW("FlashLogger", "Flash Logger already initialized.");
        return true;
    }
    
    DEBUG_LOG("Initializing Flash Logger...");
    _log_filepath = log_filepath;
    _flush_interval_ms = flush_interval_ms;
    
    // 步骤1：创建环形缓冲区。
    // 类型设为 RINGBUF_TYPE_NOSPLIT 确保日志条目在缓冲区中是连续的，不会被分割。
    _ring_buffer_handle = xRingbufferCreate(buffer_size, RINGBUF_TYPE_NOSPLIT);
    if (!_ring_buffer_handle) {
        ESP_LOGE("FlashLogger", "FATAL: Failed to create ring buffer!");
        return false;
    }

    // 步骤2：创建用于手动触发刷写的二进制信号量。
    _flush_semaphore = xSemaphoreCreateBinary();
    if (!_flush_semaphore) {
        vRingbufferDelete(_ring_buffer_handle); // 清理已创建的资源
        ESP_LOGE("FlashLogger", "FATAL: Failed to create flush semaphore!");
        return false;
    }

    // 步骤3：创建用于保护文件操作的互斥锁
    _file_mutex = xSemaphoreCreateMutex();
    if (!_file_mutex) {
        vRingbufferDelete(_ring_buffer_handle);
        vSemaphoreDelete(_flush_semaphore);
        ESP_LOGE("FlashLogger", "FATAL: Failed to create file mutex!");
        return false;
    }

    // 步骤4：创建后台刷写任务
    xTaskCreatePinnedToCore(flushTask, "FlashLog_FlushTask", 4096, this, 1, &_flush_task_handle, 1);

    ESP_LOGI("FlashLogger", "Initialized. Logging to '%s', buffer: %u B, flush interval: %u ms", 
             _log_filepath.c_str(), buffer_size, flush_interval_ms);
    return true;
}

/**
 * @brief 记录一条格式化的日志。
 */
void Sys_FlashLogger::log(const char* format, ...) {
    if (!_ring_buffer_handle) return; // 安全检查：如果未初始化则不执行任何操作
    
    char buffer[256]; // 限制单条日志的最大长度，防止栈溢出
    va_list args;
    va_start(args, format);
    int len = vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    if (len > 0) {
        // xRingbufferSend 是线程安全的，无需额外加锁。
        if (xRingbufferSend(_ring_buffer_handle, buffer, len, pdMS_TO_TICKS(10)) != pdTRUE) {
            // 缓冲区满，日志被丢弃
            ESP_LOGW("FlashLogger", "Ring buffer full, log message dropped.");
        }
    }
}

/**
 * @brief 强制刷写缓冲区。
 */
void Sys_FlashLogger::flush() {
    if (_flush_semaphore) {
        xSemaphoreGive(_flush_semaphore); // 释放信号量，以唤醒后台任务
    }
}

/**
 * @brief 线程安全地清理日志文件。
 */
void Sys_FlashLogger::clearLogFile() {
    // [优化] 关键：在接触文件系统前，获取文件互斥锁。
    Sys_LockGuard lock(_file_mutex);

    if (FFat.exists(_log_filepath)) {
        if (FFat.remove(_log_filepath)) {
            ESP_LOGI("FlashLogger", "Log file '%s' cleared.", _log_filepath.c_str());
        } else {
            ESP_LOGE("FlashLogger", "Failed to clear log file '%s'.", _log_filepath.c_str());
        }
    }
}

// --- 私有辅助方法 (Private Methods) ---

/**
 * @brief 将缓冲区数据写入文件的核心逻辑。
 */
void Sys_FlashLogger::writeBufferToFile() {
    // 步骤1：检查缓冲区是否有数据。
    // 在 ESP-IDF v5.0+ 中, vRingbufferGetInfo 的 API 已改变。
    // 使用第3个参数 uxUsed 来获取缓冲区中已用的字节数。
    // 同时，变量类型建议使用 size_t。
    size_t items_waiting = 0; 
    if (_ring_buffer_handle) {
        // 新版 API 调用，共6个参数 (handle + 5个指针)
        // 我们只需要获取 "已使用" 的大小(“可读取的字节数”的参数通常都是第3个)，所以其他指针传入 NULL
        vRingbufferGetInfo(_ring_buffer_handle, NULL, NULL, NULL, &items_waiting, NULL);
    }

    if (items_waiting == 0) {
        // 缓冲区为空，直接返回，避免不必要的文件操作
        return;
    }

    // 步骤2：获取文件锁，准备执行I/O操作
    // [优化] 使用RAII锁来保证即使发生错误也能释放锁
    Sys_LockGuard lock(_file_mutex);
    
    // 打开文件准备写入（以追加模式）
    File logFile = FFat.open(_log_filepath, "a");
    if (!logFile) {
        ESP_LOGE("FlashLogger", "Failed to open log file for appending: %s", _log_filepath.c_str());
        return;
    }
    
    DEBUG_LOG("Flushing log buffer to flash...");
    size_t total_written = 0;
    size_t item_size;
    
    // 循环处理，直到缓冲区中的所有数据项都被取出并写入
    while (true) {
        char* item = (char*)xRingbufferReceive(_ring_buffer_handle, &item_size, 0);
        if (item == NULL) {
            // 缓冲区已空，退出循环
            break;
        }

        logFile.write((uint8_t*)item, item_size);
        logFile.write('\n'); // 每条日志后添加换行符
        total_written += item_size;

        // 必须返还item的内存给ringbuffer，以便它可以被重用
        vRingbufferReturnItem(_ring_buffer_handle, (void*)item);
    }

    logFile.close();
    
    DEBUG_LOG("Flush complete. %u bytes written to '%s'.", total_written, _log_filepath.c_str());
}

/**
 * @brief 后台任务的静态循环函数。
 */
void Sys_FlashLogger::flushTask(void* parameter) {
    Sys_FlashLogger* self = (Sys_FlashLogger*)parameter;

    for (;;) {
        // 阻塞等待，直到被手动flush()或超时唤醒
        xSemaphoreTake(self->_flush_semaphore, pdMS_TO_TICKS(self->_flush_interval_ms));
        
        // 无论是哪种方式唤醒，都执行一次刷写操作。
        self->writeBufferToFile();
    }
}


### Sys_Debug.h 
//只定义全局可用的宏，依赖Sys_SettingsManager获取bool debug_mode_enabled的布尔值。

#### 不持有、不管理、不修改调试模式的状态，在任何需要打印调试信息的.cpp文件中，只需包含Debug.h即可。

##### /**
 * @file Sys_Debug.h
 * @brief 全局调试日志宏定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 本文件提供了优雅的、可配置的调试日志宏。它不包含任何.cpp实现，
 * 只定义全局可用的宏，依赖`Sys_SettingsManager`获取运行时调试状态。
 * 在任何需要打印调试信息的.cpp文件中，只需包含本文件即可。
 */
#pragma once

#include "esp_log.h"
#include "Sys_SettingsManager.h" // 关键：引入Settings管理器以查询状态

// --- 编译时开关 ---
// 这个宏从 platformio.ini 的 build_flags 中获取 (-DCORE_DEBUG_MODE=1)
// 如果没有定义，则默认为0（关闭）
#ifndef CORE_DEBUG_MODE
#define CORE_DEBUG_MODE 0
#endif

// --- 统一的日志标签 ---
// 为所有调试日志定义一个统一的TAG，便于在串口监视器中过滤
static const char* DEBUG_TAG = "CoreDebug";

/**
 * @brief 优雅的调试日志宏 (DEBUG_LOG)
 *
 * - 在编译时: 如果 CORE_DEBUG_MODE=0, 此宏展开为空，不产生任何代码，实现零开销。
 * - 在运行时: 如果 CORE_DEBUG_MODE=1, 此宏会检查 Sys_SettingsManager 中的
 *             运行时开关。只有当运行时开关也为true时，才会打印日志。
 *
 * 用法: DEBUG_LOG("Value is: %d", my_variable);
 */
#if CORE_DEBUG_MODE
    #define DEBUG_LOG(fmt, ...) \
        do { \
            /* [优化] 实时查询专用getter方法，避免不必要的结构体拷贝，性能更佳。 */ \
            if (Sys_SettingsManager::getInstance()->isDebugModeEnabled()) { \
                /* 使用 ESP-IDF 的 DEBUG 级别日志宏，输出带格式的日志 */ \
                ESP_LOGD(DEBUG_TAG, fmt, ##__VA_ARGS__); \
            } \
        } while(0)
#else
    // 如果编译时就禁用了调试模式，宏展开为空，实现零开销。
    #define DEBUG_LOG(fmt, ...)
#endif

/**
 * @brief 无条件调试日志宏 (DEBUG_LOG_ALWAYS) (可选)
 *
 * 这个宏忽略运行时的开关，只要编译时 CORE_DEBUG_MODE=1，它就会打印。
 * 用于那些即使在运行时关闭了普通调试，也希望看到的关键调试信息。
 */
#if CORE_DEBUG_MODE
    #define DEBUG_LOG_ALWAYS(fmt, ...) ESP_LOGD(DEBUG_TAG, fmt, ##__VA_ARGS__)
#else
    #define DEBUG_LOG_ALWAYS(fmt, ...)
#endif


### Sys_Diagnostics.h & .cpp
//封装从芯片信息到内存，再到分区表的硬件自检。

#### - 完全封装：所有诊断逻辑都内聚在本模块中，并提供中英双语，便于阅读。

- 编译时剥离: 使用预处理器指令，确保在发布模式下，该模块不占用任何Flash空间。

##### /**
 * @file Sys_Diagnostics.h
 * @brief 系统诊断服务模块的接口定义
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 该模块提供了一个静态的`run()`方法，用于执行一系列全面的系统检查，
 * 包括硬件信息、内存状态、分区表和文件系统。
 *
 * 它是专为开发和调试设计的工具，通过编译时宏`CORE_DEBUG_MODE`控制，
 * 在发布固件中将被完全移除，不占用任何资源。
 */
#pragma once

// 引入编译时开关的定义
#ifndef CORE_DEBUG_MODE
#define CORE_DEBUG_MODE 0 // 默认关闭
#endif

// 关键：整个模块都由编译时开关控制
#if CORE_DEBUG_MODE

#include "FS.h" // 需要 fs::FS 类型

/**
 * @class Sys_Diagnostics
 * @brief 一个用于硬件、软件配置的按需诊断服务模块。
 */
class Sys_Diagnostics {
public:
    /**
     * @brief 运行所有诊断检查，并将格式化的报告打印到串口。
     * @details 使用`ESP_LOGI`级别，确保其输出总是可见，不受运行时调试日志级别的影响。
     */
    static void run();

private:
    // 将每个诊断部分拆分为独立的私有方法，增加可读性和可维护性。
    /** @brief 检查并打印芯片、CPU、固件版本等系统信息。*/
    static void checkSystemInfo();
    /** @brief 检查并打印Flash、PSRAM、堆内存的使用情况。*/
    static void checkMemory();
    /** @brief 检查并打印实际加载的分区表信息。*/
    static void checkPartitions();
    /** @brief 检查并打印已挂载文件系统的状态和内容。*/
    static void checkFileSystems();
    /** @brief 递归列出指定目录下的文件和文件夹，是一个辅助函数。*/
    static void listDir(fs::FS& fs, const char* dirname, uint8_t levels = 0);
};

#endif // CORE_DEBUG_MODE


##### /**
 * @file Sys_Diagnostics.cpp
 * @brief 系统诊断服务模块的实现文件
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 实现了所有具体的诊断检查逻辑。
 * 通过`#if CORE_DEBUG_MODE`宏，确保本文件所有代码只在调试模式下被编译。
 */
#include "Sys_Diagnostics.h"

// 整个文件内容都受此宏保护
#if CORE_DEBUG_MODE

// --- 必要的头文件 ---
#include "esp_chip_info.h"
#include "esp_idf_version.h"
#include "esp_spi_flash.h"
#include "esp32/spiram.h"
#include "esp_heap_caps.h"
#include "esp_partition.h"
#include "Sys_Filesystem.h" // 需要获取文件系统状态

// --- 日志标签 ---
// 所有此模块的输出都会带上 `[Diagnostics]` 前缀
static const char* TAG = "Diagnostics";

// --- 主入口函数 ---

/**
 * @brief 运行所有诊断检查。
 */
void Sys_Diagnostics::run() {
    // 使用INFO级别，确保输出总是可见
    ESP_LOGI(TAG, "\n\n=============================================");
    ESP_LOGI(TAG, "      Running System Diagnostics Report");
    ESP_LOGI(TAG, "      运行系统诊断报告");
    ESP_LOGI(TAG, "=============================================");

    checkSystemInfo();
    checkMemory();
    checkPartitions();
    checkFileSystems();

    ESP_LOGI(TAG, "=============================================");
    ESP_LOGI(TAG, "      Diagnostics Complete");
    ESP_LOGI(TAG, "      诊断完成");
    ESP_LOGI(TAG, "=============================================\n");
}

// --- 私有辅助函数 ---

/**
 * @brief 检查并打印核心系统信息。
 */
void Sys_Diagnostics::checkSystemInfo() {
    ESP_LOGI(TAG, "--- 1. System Information / 系统信息 ---");
    esp_chip_info_t chip_info;
    esp_chip_info(&chip_info);
    
    ESP_LOGI(TAG, "  Chip / 芯片          : %s (rev %d)", ESP.getChipModel(), chip_info.revision);
    ESP_LOGI(TAG, "  CPU Cores / 内核数   : %d", chip_info.cores);
    ESP_LOGI(TAG, "  CPU Frequency / 频率 : %d MHz", ESP.getCpuFreqMHz());
    ESP_LOGI(TAG, "  ESP-IDF Version / 版本 : %s", esp_get_idf_version());
}

/**
 * @brief 检查并打印内存使用情况。
 */
void Sys_Diagnostics::checkMemory() {
    ESP_LOGI(TAG, "--- 2. Memory Verification / 内存验证 ---");
    
    // Flash 芯片物理大小
    ESP_LOGI(TAG, "  Flash Size (HW)    : %u MB", spi_flash_get_chip_size() / (1024 * 1024));

    // PSRAM 物理大小及编译模式
    if (esp_spiram_is_initialized()) {
        ESP_LOGI(TAG, "  PSRAM Size (HW)    : %u MB", esp_spiram_get_size() / (1024 * 1024));
        #if CONFIG_SPIRAM_MODE_OCT
            ESP_LOGI(TAG, "  PSRAM Mode (Compile) : OPI (Octal)");
        #elif CONFIG_SPIRAM_MODE_QUAD
            ESP_LOGI(TAG, "  PSRAM Mode (Compile) : QPI (Quad)");
        #endif
    } else {
        ESP_LOGW(TAG, "  PSRAM              : Not detected or not enabled!");
    }
    
    // 堆内存 (Heap) 分布情况
    ESP_LOGI(TAG, "  Heap (Internal)    : %u KB Free / %u KB Total", heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024, heap_caps_get_total_size(MALLOC_CAP_INTERNAL) / 1024);
    ESP_LOGI(TAG, "  Heap (PSRAM)       : %u KB Free / %u KB Total", heap_caps_get_free_size(MALLOC_CAP_SPIRAM) / 1024, heap_caps_get_total_size(MALLOC_CAP_SPIRAM) / 1024);
    
    // 确认PSRAM是否被成功集成
    if (heap_caps_get_total_size(MALLOC_CAP_SPIRAM) > 0) {
        ESP_LOGI(TAG, "  [OK] PSRAM is successfully integrated into the heap.");
    } else {
        ESP_LOGE(TAG, "  [FAIL] PSRAM not integrated! Check build flags & board config.");
    }
}

/**
 * @brief 检查并打印分区表。
 */
void Sys_Diagnostics::checkPartitions() {
    ESP_LOGI(TAG, "--- 3. Partition Table Verification / 分区表校验 ---");
    ESP_LOGI(TAG, "  %-10s | %-9s | %-10s | %-12s | %-s", "Type", "Subtype", "Address", "Size (bytes)", "Label");
    ESP_LOGI(TAG, "  -------------------------------------------------------------------");

    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);
    if (!it) {
        ESP_LOGE(TAG, "  Error: Could not find any partitions!");
        return;
    }
    
    while (it != NULL) {
        const esp_partition_t *part = esp_partition_get(it);
        char addr_str[11], size_str[13];
        snprintf(addr_str, sizeof(addr_str), "0x%08X", part->address);
        snprintf(size_str, sizeof(size_str), "%u", part->size);

        ESP_LOGI(TAG, "  %-10s | %-9d | %-10s | %-12s | %-s",
                 (part->type == ESP_PARTITION_TYPE_APP) ? "app" : "data",
                 part->subtype,
                 addr_str,
                 size_str,
                 part->label);
        
        it = esp_partition_next(it);
    }
    esp_partition_iterator_release(it);
    ESP_LOGI(TAG, "  [INFO] Compare this table with your 'my_8MB.csv' file.");
}

/**
 * @brief 检查并打印文件系统状态。
 */
void Sys_Diagnostics::checkFileSystems() {
    ESP_LOGI(TAG, "--- 4. File System Status / 文件系统状态 ---");
    Sys_Filesystem* fs = Sys_Filesystem::getInstance();
    
    if (fs->isLittleFSMounted()) {
         ESP_LOGI(TAG, "  LittleFS (UI)      : Mounted. Total: %llu KB, Used: %llu KB",
                 fs->getLittleFSTotalBytes() / 1024, fs->getLittleFSUsedBytes() / 1024);
         listDir(LittleFS, "/", 1); // 列出根目录内容，递归1层
    } else {
        ESP_LOGE(TAG, "  LittleFS (UI)      : [FAIL] Not mounted!");
    }
    
    if (fs->isFFatMounted()) {
        ESP_LOGI(TAG, "  FFat (Media)       : Mounted. Total: %.2f MB, Used: %.2f MB",
                 (float)fs->getFFatTotalBytes() / (1024*1024), (float)fs->getFFatUsedBytes() / (1024*1024));
        listDir(FFat, "/"); // 列出根目录内容
    } else {
        ESP_LOGE(TAG, "  FFat (Media)       : [FAIL] Not mounted!");
    }
}

/**
 * @brief 递归列出目录内容。
 * @details 这是一个辅助函数，用于checkFileSystems。
 */
void Sys_Diagnostics::listDir(fs::FS &fs, const char * dirname, uint8_t levels) {
    ESP_LOGI(TAG, "    Listing directory: %s", dirname);

    File root = fs.open(dirname);
    if(!root){
        ESP_LOGE(TAG, "    - Failed to open directory");
        return;
    }
    if(!root.isDirectory()){
        ESP_LOGE(TAG, "    - Not a directory");
        return;
    }

    File file = root.openNextFile();
    while(file){
        if(file.isDirectory()){
            ESP_LOGI(TAG, "    DIR : %s", file.name());
            if(levels){
                listDir(fs, file.name(), levels - 1);
            }
        } else {
            ESP_LOGI(TAG, "    FILE: %s  SIZE: %u", file.name(), file.size());
        }
        file = file.openNextFile();
    }
}

#endif // CORE_DEBUG_MODE


### Sys_types.h
//是一个专门的“类型定义层”接口，专门管理不属于任何特定模块的公共头文件。

#### 用于存放所有跨模块共享的数据类型定义。
当Command添加一个新的类型时，在types.h里增加。

##### /**
 * @file types.h
 * @brief 定义项目中跨模块共享的公共数据类型、结构体和枚举。
 * @author [ANEAK]
 * @date [2025/7]
 *
 * @details
 * 这个文件旨在解决模块间的类型依赖问题。任何被多个模块
 * 使用的数据结构都应该在这里定义，以提供一个“单一事实来源”，
 * 避免重复定义和不明确的`extern`声明。
 */
#pragma once
#include <stdint.h> // For uint32_t

/**
 * @struct JsonRpcRequest
 * @brief 定义了从前端接口到Task_Worker的JSON RPC 2.0请求的内部表示。
 *        它被放入命令队列中，由Task_Worker消费。
 */
struct JsonRpcRequest {
    /** @brief JSON RPC 请求的ID，用于匹配响应。对于通知，此ID可能无效或为0。*/
    uint32_t id = 0;

    /** @brief 发起请求的WebSocket客户端ID，用于定向响应。*/
    uint32_t client_id = 0;

    /** @brief JSON RPC 的方法名 (例如 "system.reboot", "settings.saveWiFi")。*/
    char method[64] = "";

    /** @brief 携带JSON RPC的`params`对象的JSON字符串。*/
    char params[512] = "";
};

// --- 未来可以添加其他共享类型 ---
/*
struct SystemEvent {
    enum class Source { WIFI, BLUETOOTH, SENSOR };
    Source source;
    int event_code;
};
*/

### Sys_LockGuard.h
//封装 RAII 模式的锁守护者类

#### 目的是从根本上消除因忘记调用 xSemaphoreGive() 而导致的死锁风险。

##### /**
 * @file Sys_LockGuard.h
 * @brief 一个通用的、基于RAII模式的FreeRTOS互斥锁守护者
 * @author [ANEAK] & AI Assistant
 * @date [2025/7]
 *
 * @details
 * 该类遵循RAII (Resource Acquisition Is Initialization) 模式。
 * 在其构造函数中获取互斥锁，在其析构函数中释放互斥锁。
 * 只需在需要保护的代码块的开头，在栈上创建一个此类的对象，
 * 即可保证无论函数如何退出（正常返回、异常抛出），锁都一定会被释放，
 * 从而彻底避免忘记解锁导致的死锁问题。
 *
 * @example
 * void threadSafeFunction() {
 *     Sys_LockGuard lock(_my_mutex); // 在构造时加锁
 *     // ... 此处是受保护的临界区代码 ...
 * } // 函数结束时，lock对象被销毁，析构函数自动解锁
 *
 */
#pragma once

#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

class Sys_LockGuard {
public:
    /**
     * @brief 构造函数，立即获取互斥锁并阻塞等待。
     * @param mutex 要管理的FreeRTOS互斥信号量句柄。
     */
    explicit Sys_LockGuard(SemaphoreHandle_t& mutex) : _mutex(mutex) {
        // [优化] 增加对NULL句柄的检查，提高健壮性。
        if (_mutex != NULL) {
            xSemaphoreTake(_mutex, portMAX_DELAY);
        }
    }

    /**
     * @brief 析构函数，自动释放互斥锁。
     */
    ~Sys_LockGuard() {
        // [优化] 增加对NULL句柄的检查。
        if (_mutex != NULL) {
            xSemaphoreGive(_mutex);
        }
    }

    // 删除拷贝构造函数和赋值操作符，确保锁的所有权不被转移。
    // 这是保证RAII模式正确性的关键。
    Sys_LockGuard(const Sys_LockGuard&) = delete;
    Sys_LockGuard& operator=(const Sys_LockGuard&) = delete;

private:
    /** @brief 对要管理的互斥锁的引用。*/
    SemaphoreHandle_t& _mutex;
};


### Sys_CamManager.h & .cpp 
//封装USB摄像头管理相关。

## 阶段性实施方案 (Phased Implementation Plan)

### 阶段0：基础环境核心框架与诊断系统 (The Bedrock)
验证标准：验证硬件驱动、内存系统和文件系统均按设计正确初始化，为上层软件提供一个稳定可靠的运行平台。- 此阶段不涉及任何网络Web功能 -

#### 涉及模块：
Sys_NvsManager.h/.cpp 
Sys_Filesystem.h/.cpp 
Sys_MemoryManager.h/.cpp 
Sys_Diagnostics.h/.cpp 

#### 环境搭建：
配置platformio.ini，板定义文件 boards/esp32s3_n8r8.json正确。

#### 内存验证：
实现 Sys_MemoryManager，初始化多池内存池并集成到堆内存；通过一个临时的、只在调试模式下编译的单元测试函数，循环分配和释放所有内存池中的块，验证无泄漏、无地址冲突。

#### 分区实现：
Flash的正确设置并引用自定义分区表：my_8MB.csv。

#### 文件系统挂载：
实现 Sys_Filesystem，完成 LittleFS 和 FFat 的挂载。

#### 诊断系统：
实现 Sys_Diagnostics 模块，用于在串口打印全面的硬件自检报告。

#### 设备在环测试：
串口监视器打印详细诊断信息。

### 阶段1：核心服务与任务调度 (The Engine)
验证标准：系统能够独立运行，并根据持久化的配置管理自身状态（如WiFi重连）。所有核心后台任务都能按预期调度。- 此阶段不涉及Web UI -

#### 涉及模块：
Sys_SettingsManager.h/.cpp 
Sys_WiFiManager.h/.cpp 
Sys_Tasks.h/.cpp 
types.h 

#### 任务调度器：
系统正常运行FreeRTOS任务调度器（系统心脏），并建立起核心的异步服务，为上层应用提供非阻塞的服务支持。

#### NVS配置：
实现Sys_NvsManager和Sys_SettingsManager。在SystemSettings结构体的默认成员初始化中定义这些默认值。

#### WIFI管理器：
实现事件驱动的 Sys_WiFiManager，使其能够在后台非阻塞地处理连接、断开和重连逻辑。

#### 核心任务启动：
创建并运行 Task_SystemMonitor，验证其能周期性调用 Sys_WiFiManager::update() 和 Sys_SettingsManager::commit()、创建并运行 Task_Worker，验证其能阻塞在空的 xCommandQueue 上。

#### WiFi连接成功后能在串口看到获取到的IP地址。如果连接失败，会看到周期性的重连尝试日志。

### 阶段2：前后端通信管道 (The Conduit)
验证标准：通过设备IP地址能成功访问 index.html；运行时间能按需要更新，点击按钮后ESP32有正确的响应。用以证明从UI到任务再回到UI的整条链路通畅。

#### 涉及模块：
Sys_WebServer.h/.cpp
Sys_Tasks.h/.cpp (修改调用方式)
前端资源 (/data/index.html 等)

#### Web服务器启动：
实现 Sys_WebServer，启动HTTP和WebSocket服务。

#### 静态页面服务：
/data 录建立Web页面index.html，可通过获取到的IP地址访问。

#### 后端->前端 (数据流)： 
创建 Task_WebSocketPusher，使其能从 xStateQueue 接收数据并通过WebSocket广播。

#### 前端->后端 (命令流)：
在 index.html 中实现连接WebSocket、接收并实时显示系统运行时间、点击“重启”“恢复出厂设置”按钮时的JS逻辑。
页面上有一个“获取系统状态”按钮。点击后，通过WebSocket发送一个JSON命令（如{"command": "get_status"}）。在设备的串口能看到Task_Worker收到该命令的日志。

#### 修改 Sys_WebServer 的WebSocket回调，将收到的命令放入 xCommandQueue。Task_Worker 接收到REBOOT命令后执行 ESP.restart()。

### 阶段3：高级功能与UI完善 (The Polish)
验证标准：在已验证的通信框架上，填充具体的功能模块，实现设计中的核心用户交互。阶段结束时，设备的核心配置能力应完全通过Web UI暴露给用户。

#### 用户可通过Web界面完整地配置设备的WiFi/蓝牙功能并监控其运行状态；所有操作都有即时、友好的UI反馈（Toast、Modal、Spinner）；设备的详细运行日志能在Web界面上实时查看。

#### 仪表盘 的前后端细化及完善

##### UI布局完成，能响应式地适应桌面和移动端。

##### get_system_status命令能返回所有必要的系统信息，并在前端正确渲染。

##### 实现带模态框确认的“重启”、“恢复出厂设置”、手动刷新、调试模式的功能。

#### WiFi管理模块 前后端细化及完善

##### UI布局完成，包含WIFI功能的总开关和AP/STA/AP+STA模式切换、SSID/密码输入框和可折叠的静态IP设置。

##### 数据流：get_wifi_settings 和 save_wifi_settings 命令与HTTP API端点实现，前端能正确加载和保存配置。

##### “扫描网络”功能可用，能将结果显示在模态框中供用户选择。

##### 保存新配置后，能触发Sys_WiFiManager应用新设置，并尝试连接。

#### 蓝牙管理模块 前后端细化及完善

##### 采用WIFI模块相同的设计模式；UI布局完成后，包含蓝牙功能的总开关和蓝牙广播名称的设置表单和设备列表功能。

#####  实现 get_ble_settings 和 save_ble_settings 命令与API，能加载和持久化蓝牙配置到NVS。

##### 当用户通过UI更改设置并保存后，Sys_BluetoothManager（待实现）能加载新配置，例如更改蓝牙广播的设备名称。

##### 实现蓝牙PAN配网的UI切换逻辑，虽然完整的PAN功能可能更复杂，但至少UI层面应该有所体现。

##### 完善A2DP播放功能，至少UI层面应该有所体现。

#### 日志系统模块  前后端细化及完善

##### ESP_LOG的输出能被实时捕获。

##### 通过WebSocket数据流 (log类型消息)，将格式化后的日志（带级别和时间戳）推送到前端。

##### 仪表盘的日志控制台能根据日志级别以不同颜色显示，并能自动滚屏。

### 阶段4：后期开发计划

#### USB摄像头模块 前后端细化及完善

#### OTA管理模块 前后端细化及完善

#### 中、英文语言系统 前后端细化及完善

#### 安全验证与远程API对接 前后端细化及完善

## 功能模块化详细设计 (Functional Module Design)

### 仪表盘

#### UI布局：

##### 顶部：一行4个关键指标卡片，分别显示：运行时间(秒／时／天／月／年按时长切换显示)、通用堆内存、PSRAM内存池、WiFi当前模式及状态。

##### 中部：左侧为系统信息列表（芯片型号、CPU频率、PSRAM、FLASH、版本等多种全面信息），右侧为各模块功能（WIFI管理模块、蓝牙管理模块、USB摄像头模块）的开关或模式状态。全局操作按钮（重启、恢复出厂）和

##### 底部：日志控制台。

#### 功能实现：

##### 数据加载：首次页面加载完成和WebSocket重连成功时，前端自动发送`get_system_status`命令。之后由“手动刷新”按钮按需触发。

##### 数据源：后端`taskWorker`接收到命令后，从各个系统API和管理模块获取最新数据，打包成`system_status`类型的JSON进行广播。

##### 操作：点击“重启”或“恢复出厂”按钮，弹出模态框确认。确认后，前端发送`reboot`或`factory_reset`命令，由`taskWorker`执行相应操作。

### WiFi管理模块

#### UI布局：

##### 总开关：一个Toggle Switch用于启用/禁用WIFI功能。需要模态框 (Modal)**进行二次确认，提醒关闭的影响。

##### 模式切换：使用一组“内联单选按钮”在**AP**、**STA**、**AP+STA**三种模式间切换。

##### STA配置：包含SSID输入框（带“扫描网络”按钮）和密码输入框（带可见性切换按钮）。仅在STA或AP+STA模式下可见。

##### AP配置：包含AP SSID和AP密码输入框，仅在AP或AP+STA模式下可见。

##### 静态IP：使用一个可折叠的Collapse组件，内含静态IP、子网掩码、网关的配置项。仅在STA或AP+STA模式下可见。

#### 功能实现：

##### 交互逻辑：当总开关关闭时，关闭WIFI全部功能、各项设置或按钮被禁用并灰显。

##### 数据加载：进入本模块页面时，前端自动发送`get_wifi_settings`命令，后端返回所有已保存的WiFi配置用于填充表单。

##### 扫描网络：点击“扫描网络”按钮，前端发送`scan_wifi_networks`命令。后端`taskWorker`执行扫描，扫描时UI上必须有明确的指示器避免用户认为应用卡死并提示仅支持2.4G网络。得到结果后通过`wifi_scan_result`消息返回网络列表。前端将列表动态填充到模态框中供用户选择。

##### 保存配置：点击“保存”按钮，前端将整个表单序列化为JSON，通过`save_wifi_settings`命令发送。后端`taskWorker`解析数据，调用`Sys_SettingsManager`保存到NVS，然后调用`Sys_WiFiManager`应用新配置。

### 6.3 蓝牙管理模块 (下一步开发)

#### UI布局：

##### 总开关：一个Toggle Switch用于启用/禁用蓝牙功能。需要模态框 (Modal)**进行二次确认，提醒关闭的影响。

##### 设置表单：一个输入框组用于设置蓝牙广播名称。

##### 已配对列表：显示保存过的蓝牙设备名称列表，点击名称可快速连接该设备。

##### PAN接口IP：使用一个可折叠的Collapse组件，内含PAN静态IP、子网掩码、DHCP起始IP、结束IP的配置项。仅在蓝牙PAN启用下可见。

##### 刷新按钮：用于扫描附近蓝牙设备

#### 蓝牙PAN配网(使用BLE5.0实现)：

##### 从platformio.ini获取PAN相关配置

#### 蓝牙播放A2DP协议栈(本项目无经典蓝牙暂停实现)：

##### 蓝牙音频用于播放简短的警告提示音（如ADPCM WAV文件）高优先级操作时降低蓝牙或暂停活动

##### 采用“连接-播放-断开” 的懒加载策略，动态连接管理需要与蓝牙设备保持长连接；触发播放时链连接；任务完成后，启动一个计时器（例如30秒），如果期间没有新的播放请求，则主动断开与音箱的连接，释放无线电资源。

#### 功能实现：

##### 交互逻辑：当总开关关闭时，关闭蓝牙全部功能、各项设置或按钮被禁用并灰显。

##### **后端**: 实现`save_ble_settings`命令，将蓝牙开关状态和设备名称所有蓝牙设置保存到NVS。`Sys_BluetoothManager`（待创建）在启动时加载此配置。

##### 蓝牙PAN配网

#### 共存策略：

##### 必须考虑WiFi与蓝牙共享同一个物理射频和天线的共存问题。在进行WiFi密集型操作（如OTA）时，应通过ESP-IDF提供的共存（Coexistence）API暂时降低蓝牙活动或完全禁用蓝牙。

### USB摄像头模块 (未来规划)

#### UI布局：

##### 总开关：一个Toggle Switch用于启用/禁用摄像头功能。

##### 摄像头切换按钮，可在获取到的不同摄像头之间可切换画面

##### 播放、暂停、拍照按钮

##### 视频流：使用一个`<img>`标签指向选定的视频流地址，并添加`.img-fluid` class使其自适应容器宽度。

##### 参数设置：使用可折叠的Collapse组件提供控制获取到摄像头内置的属性（分辨率、帧率、图片格式、图像调节、UAC音频声音大小等）。

#### USB依赖库：ESP32_USB_Stream 
负责从摄像头UVC获取 MJPEG/YUYV 帧，并可能进行 MJPEG 解码，从UAC获取音声

##### https://github.com/esp-arduino-libs/ESP32_USB_Stream

#### 条码二维码识别
初步选型 zxing-cpp、ZBar等集成

##### https://github.com/zxing-cpp/zxing-cpp
https://github.com/espressif/esp-idf-camera-scans-barcode-example

#### 功能实现：

##### 后端`Sys_WebServer`需要提供一个HTTP端点（如`/stream`），用于输出MJPEG视频流。

##### `Task_ImageProcessor` (Core 0) 负责从摄像头获取帧，`Task_WebServer` (Core 1) 负责将帧数据通过HTTP流式传输给前端。

---

##### 将识别结果通过`xBarcodeQueue`队列发送给`taskWebSocketPusher`，并实时显示在Web UI上。

### OTA管理模块 (未来规划)
Web固件上传和更新功能。

#### UI布局：

##### OTA设置项：有输入框用于填写固件服务器URL，有占位符文本用于提示需要输入的内容，已设置则读取显示设置的值。
有一个“检查更新”按钮。

##### 有文件上传框，占位符提示需要输入的内容；上传框后面有校验按钮，上传完成后校验按钮可用，校验成功则更新按钮可用，校验失败则模态框提示“固件无效或已损坏，请检查文件”。

##### 点击“更新”后，禁用页面所有其他功能，模态框提示显示一个带百分比的进度条，例如 (Progress Bar)，“正在上传... 请勿断电或关闭页面”。

#### 功能实现：

##### 创建监听事件来实时更新进度条的宽度或百分比文本。

##### 后端校验：在设备接收完整固件后，在写入Flash之前，必须对其进行后端校验：数字签名验证或CRC/MD5校验。 数字签名可以防止恶意固件被上传和执行。

### 中、英文语言系统 (未来规划)
(i18n JSON)

#### UI布局：

##### 前后端语言选择：一个Toggle Switch用于语言切换

#### zh.json

#### en.json

#### 功能实现：

##### 在启动时根据用户配置或浏览器语言，只加载需要的json到PSRAM的一个全局JsonDocument中，后续文本从内存对象读取而不是访问文件系统，提高效率

##### 热加载： 
如果可能，实现语言文件的热加载，无需重启设备即可切换语言。

### 安全验证与远程API对接 (未来规划)

#### 实现基于表单的Web登录认证。
